{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CS 6332 Home Welcome to CS 6332: Systems Security and Binary (Malicious) Code Analysis. News 08/19/2019: Course site open. Welcome! Page last revised on: 2019-08-27","title":"CS 6332 Home"},{"location":"#cs-6332-home","text":"Welcome to CS 6332: Systems Security and Binary (Malicious) Code Analysis.","title":"CS 6332 Home"},{"location":"#news","text":"08/19/2019: Course site open. Welcome! Page last revised on: 2019-08-27","title":"News"},{"location":"assignment01/","text":"Assignment 0x01 Assignment set-up We have a submission server (10.176.90.84) set-up for this assignment. Student will log-in with different accounts for different parts of assignment. From you host (Linux or OSX), use the following command to log-in to the submission server. We a same password for all accounts, the log-in password is guest . # For part 1 $ ssh -p 2222 assign_0x1_p1@10.176.90.84 assign_0x1_p1@10.176.90.84 password: # type in \"guest\" ... # For part 2 $ ssh -p 2222 assign_0x1_p2@10.176.90.84 assign_0x1_p2@10.176.90.84 password: # type in \"guest\" ... # For part 3 $ ssh -p 2222 assign_0x1_p3@10.176.90.84 assign_0x1_p3@10.176.90.84 password: # type in \"guest\" ... Assignment binaries Assignment binaries are available for download. Download and study it from local machine first. Once you figure out how to solve, you can login to submission server to get flags for each part. assign_0x1_p1 assign_0x1_p2 assign_0x1_p3 Capturing the flag! Once you log into your system, you will see the files of the followings. assign_0x1_p1@cs6332-lab0:~$ ls -trl total 24 -r-xr-sr-x 1 root assign_0x1_p1_pwn 7376 Sep 20 05:27 assign_0x1_p1 -r-xr-x--- 1 root assign_0x1_p1_pwn 424 Sep 20 05:34 solve For each part, the goal is to run solve to get your flag. With the correct input to each part, you will get to run solve , and it will give you the following prompt. Which will ask you to provide your NetID and student ID. Your NetID: kxj1234556 Your student ID: 25415 Here is your answer hash: 19154be089a9f0cf7627a68bcfd1c26f Your student ID will be gained by the following command. m=$(echo \"kxj1234556\" |md5sum |cut -d ' ' -f 1);echo \"obase=10; ibase=16; ${m: -4}\" |bc As you solve different parts of the assignment, each part will produce different hashes. You can submit the hash values. GDB Plug-ins You can find PEDA and gef . You can enable a plug-in by running the following commands from GDB . source /opt/gef/gef.py source /opt/peda/peda.py In this document, I will use PEDA GDB Plugin, to illustrate assignment details. You can also try to use more updated GDB plug-ins such as pwndbg . Part 1 (4pt): Control flow hijacking Preparation Download assign_0x1_p1 from http://cs6332.syssec.org/crackmes/assign_0x1_p1 Description In this assignment, we are going to hijack the control flow of assign_0x1_p1 binary by overwriting the instruction pointer. As a first step, let\u2019s make it print out \u201cPassword OK :)\u201d without providing correct answer to your question. $ objdump -d assign_0x1_p1 ... 8048469: e8 e2 fe ff ff call 8048350 <strcmp@plt> 804846e: 85 c0 test %eax,%eax 8048470: 74 0e je 8048480 <main+0x6c> 8048472: c7 04 24 96 85 04 08 movl $0x8048596,(%esp) 8048479: e8 c2 fe ff ff call 8048340 <printf@plt> 804847e: eb 0c jmp 804848c <main+0x78> -> 8048480: c7 04 24 a9 85 04 08 movl $0x80485a9,(%esp) 8048487: e8 b4 fe ff ff call 8048340 <printf@plt> 804848c: b8 00 00 00 00 mov $0x0,%eax 8048491: c9 leave 8048492: c3 ret main function will return to 0x08048480 such that it prints out \u201cPassword OK :)\u201d. Which characters in input should be changed to 0x08048480? Let me remind you that x86 is a little-endian machine. What happens if you provide a long string? Like below. $ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA | ././assign_0x1_p1 CS6332 Crackme Level 0x00 Password: Invalid Password! Segmentation fault There are a few ways to check the status of the last segmentation fault: checking logging messages $ dmesg | tail -1 [237413.117757] assign_0x1_p1[353]: segfault at 41414141 ip 0000000041414141 sp 00000000ff92aef0 error 14 in libc-2.24.so[f7578000+1b3000] running gdb $ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA > input $ gdb ./assign_0x1_p1 > run <input Starting program: ./assign_0x1_p1 <input CS6332 Crackme Level 0x00 Password: Invalid Password! Program received signal SIGSEGV, Segmentation fault. 0x41414141 in ?? () Control EIP Let\u2019s figure out which input tainted the instruction pointer. $ echo AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJ > input $ ./assign_0x1_p1 <input $ dmesg | tail -1 [238584.915883] assign_0x1_p1[1095]: segfault at 48484848 ip 0000000048484848 sp 00000000ffc32f80 error 14 in libc-2.24.s What\u2019s the current instruction pointer? You might need this help: $ man ascii You can also figure out the exact shape of the stack frame by looking at the instructions as well. $ r2 assign_0x1_p1 ... 8048414: 55 push %ebp 8048415: 89 e5 mov %esp,%ebp 8048417: 83 ec 28 sub $0x28,%esp ... 8048448: 8d 45 e8 lea -0x18(%ebp),%eax 804844b: 89 44 24 04 mov %eax,0x4(%esp) 804844f: c7 04 24 8c 85 04 08 movl $0x804858c,(%esp) 8048456: e8 d5 fe ff ff call 8048330 <scanf@plt> ... Note Successful control hijack will eventually run system(\u201c/home/assign_0x1_p1/solve\u201d) ! Look inside the binary! The following is the disassembly of assign_0x1_p1 binary. $ r2 assign_0x1_p1 .... \u250c (fcn) main 136 .... \u2502 0x080485c2 e809feffff sym.imp.strcmp () ; int strcmp(const char *s1, const char *s2) \u2502 0x080485c7 83c408 esp += 8 \u2502 0x080485ca 85c0 var = eax & eax \u2502 \u250c\u2500< 0x080485cc 751c if (var) goto 0x80485ea \u2502 \u2502 0x080485ce 68ac860408 push str.Password_OK_: ; 0x80486ac ; \"Password OK :)\" \u2502 \u2502 0x080485d3 e838feffff sym.imp.puts () ; int puts(const char *s) \u2502 \u2502 0x080485d8 83c404 esp += 4 \u2502 \u2502 0x080485db 68bb860408 push str.home_assign_0x1_p1_solve ; 0x80486bb ; \"/home/assign_0x1_p1/solve\" \u2502 \u2502 0x080485e0 e83bfeffff sym.imp.system () ; int system(const char *string) \u2502 \u2502 0x080485e5 83c404 esp += 4 \u2502 \u250c\u2500\u2500< 0x080485e8 eb0d goto 0x80485f7 \u2502 \u2502\u2502 ; JMP XREF from 0x080485cc (main) \u2502 \u2502\u2514\u2500> 0x080485ea 68d5860408 push str.Invalid_Password ; 0x80486d5 ; \"Invalid Password!\" \u2502 \u2502 0x080485ef e81cfeffff sym.imp.puts () ; int puts(const char *s) \u2502 \u2502 0x080485f4 83c404 esp += 4 \u2502 \u2502 ; JMP XREF from 0x080485e8 (main) \u2502 \u2514\u2500\u2500> 0x080485f7 b800000000 eax = 0 \u2502 0x080485fc c9 \u2514 0x080485fd c3 return 0 Output to submit Save your attack payload to input1 . The expected running example would be like the following. $ cat input1 | ./assign_0x1_p1 CS6332 Crackme Level 00 Password: Invalid Password! Password OK :) Segmentation fault Part 2 (8 point): Return-to-libc Preparation For this part, we will use assign_0x1_p1 binary again. Download assign_0x1_p1 from http://cs6332.syssec.org/crackmes/assign_0x1_p1 and check its binary to ensure stack section ( GNU_STACK ) is in RW permission which mean you can overwrite a stack, but cannot run any code from there. $ readelf -W -l ./assign_0x1_p2|grep STACK GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4 Description From this part of the assignment, you can still hijack the control by overwriting the return address, but you don\u2019t know where to transfer the control, to run the desired command (say /bin/sh ). In this part of the assignment, we want to use system() function provided by Glibc library. For its usage, please check out man -s 3 system . Please write an input that would overwrite the address of system() to return address of main() and transfer the control aa main() function returns. Don\u2019t forget to find a way to pass a string of command that you want to run ( /bin/sh ) as the first function argument to system() function. You can provide it from your stack or you can simply search for the string from Glibc. system() function example The above snippet would give you a command prompt. $ cat << EOF > /tmp/system.c #include <stdlib.h> // system.c int main() { system(\"/bin/sh\"); } EOF $ gcc /tmp/system.c $ ./a.out $ whoami kjee Getting addresses of necessary ingredients. GDB (Peda) will the address of system() at runtime. $ gdb assign_0x1_p2 gdb-peda$ b main gdb-peda$ run ... gdb-peda$ print system $1 = {<text variable, no debug info>} 0xf7e26d10 <system> 0xf7e26d10 is address that you want to return to run the function. Output to submit Save your attack payload to input2 . The expected running example would be like the following. You will pretend env -i , so as for the stack layout to be more deterministic. $ cat input2 | env -i ./assign_0x1_p2 CS6332 Crackme Level 00 Password: Invalid Password! .... $ sh ./solve .... Part 3 (8 piont): Jump to your own shellcode Preparation Download assign_0x1_p3 from http://cs6332.syssec.org/crackmes/assign_0x1_p3 and check its binary to ensure stack section ( GNU_STACK ) is in RWE permission which mean you can write and run a shellcode snippet from stack. $ readelf -W -l ./assign_0x1_p3|grep STACK GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10 Description From this assignment, PEDA will generate a shellcode. You will craft an input to overwrite the stack with shellcode and transfer control the beginning of shellcode as main() function returns. You can google for execve() shellcode x86 that would eventually run /bin/sh command for you. Check shellcode length, and make sure shellcode should fit in to stack. Let\u2019s see we have enough space in stack. $ objdump -j .text -d assign_0x1_p3 ... 5bc: 83 ec 20 sub $0x30,%esp ... Create an input that would run shellcode and subsequently give /bin/sh prompt. Please note that different lengths of environment variables + arguments can also vary the resulting stack address widely from computer to computer. A way to mitigate this issue is doing a NOP slide (see https://old.liveoverflow.com/binary_hacking/protostar/stack5.html). Output to submit Save your attack payload to input2 . The expected running example would be like the following. You will pretend env -i , so as for stack layout to be more deterministic. $ cat input3 | env -i ./assign_0x1_p3 CS6332 Crackme Level 00 Password: Invalid Password! ... $ sh ./solve .... Submission Submit a file with following entries. NetID: <Your NetID> * Part 1 <hash from /home/assign_0x1_p1/solve> * Part 2 <hash from /home/assign_0x1_p2/solve> * Part 3 <hash from /home/assign_0x1_p3/solve> [Credit] : Henry Wang has significantly contributed to improve the assignment. Page last revised on: 2019-09-20","title":"assignment 0x01"},{"location":"assignment01/#assignment-0x01","text":"","title":"Assignment 0x01"},{"location":"assignment01/#assignment-set-up","text":"We have a submission server (10.176.90.84) set-up for this assignment. Student will log-in with different accounts for different parts of assignment. From you host (Linux or OSX), use the following command to log-in to the submission server. We a same password for all accounts, the log-in password is guest . # For part 1 $ ssh -p 2222 assign_0x1_p1@10.176.90.84 assign_0x1_p1@10.176.90.84 password: # type in \"guest\" ... # For part 2 $ ssh -p 2222 assign_0x1_p2@10.176.90.84 assign_0x1_p2@10.176.90.84 password: # type in \"guest\" ... # For part 3 $ ssh -p 2222 assign_0x1_p3@10.176.90.84 assign_0x1_p3@10.176.90.84 password: # type in \"guest\" ...","title":"Assignment set-up"},{"location":"assignment01/#assignment-binaries","text":"Assignment binaries are available for download. Download and study it from local machine first. Once you figure out how to solve, you can login to submission server to get flags for each part. assign_0x1_p1 assign_0x1_p2 assign_0x1_p3","title":"Assignment binaries"},{"location":"assignment01/#capturing-the-flag","text":"Once you log into your system, you will see the files of the followings. assign_0x1_p1@cs6332-lab0:~$ ls -trl total 24 -r-xr-sr-x 1 root assign_0x1_p1_pwn 7376 Sep 20 05:27 assign_0x1_p1 -r-xr-x--- 1 root assign_0x1_p1_pwn 424 Sep 20 05:34 solve For each part, the goal is to run solve to get your flag. With the correct input to each part, you will get to run solve , and it will give you the following prompt. Which will ask you to provide your NetID and student ID. Your NetID: kxj1234556 Your student ID: 25415 Here is your answer hash: 19154be089a9f0cf7627a68bcfd1c26f Your student ID will be gained by the following command. m=$(echo \"kxj1234556\" |md5sum |cut -d ' ' -f 1);echo \"obase=10; ibase=16; ${m: -4}\" |bc As you solve different parts of the assignment, each part will produce different hashes. You can submit the hash values.","title":"Capturing the flag!"},{"location":"assignment01/#gdb-plug-ins","text":"You can find PEDA and gef . You can enable a plug-in by running the following commands from GDB . source /opt/gef/gef.py source /opt/peda/peda.py In this document, I will use PEDA GDB Plugin, to illustrate assignment details. You can also try to use more updated GDB plug-ins such as pwndbg .","title":"GDB Plug-ins"},{"location":"assignment01/#part-1-4pt-control-flow-hijacking","text":"","title":"Part 1 (4pt): Control flow hijacking"},{"location":"assignment01/#preparation","text":"Download assign_0x1_p1 from http://cs6332.syssec.org/crackmes/assign_0x1_p1","title":"Preparation"},{"location":"assignment01/#description","text":"In this assignment, we are going to hijack the control flow of assign_0x1_p1 binary by overwriting the instruction pointer. As a first step, let\u2019s make it print out \u201cPassword OK :)\u201d without providing correct answer to your question. $ objdump -d assign_0x1_p1 ... 8048469: e8 e2 fe ff ff call 8048350 <strcmp@plt> 804846e: 85 c0 test %eax,%eax 8048470: 74 0e je 8048480 <main+0x6c> 8048472: c7 04 24 96 85 04 08 movl $0x8048596,(%esp) 8048479: e8 c2 fe ff ff call 8048340 <printf@plt> 804847e: eb 0c jmp 804848c <main+0x78> -> 8048480: c7 04 24 a9 85 04 08 movl $0x80485a9,(%esp) 8048487: e8 b4 fe ff ff call 8048340 <printf@plt> 804848c: b8 00 00 00 00 mov $0x0,%eax 8048491: c9 leave 8048492: c3 ret main function will return to 0x08048480 such that it prints out \u201cPassword OK :)\u201d. Which characters in input should be changed to 0x08048480? Let me remind you that x86 is a little-endian machine. What happens if you provide a long string? Like below. $ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA | ././assign_0x1_p1 CS6332 Crackme Level 0x00 Password: Invalid Password! Segmentation fault There are a few ways to check the status of the last segmentation fault: checking logging messages $ dmesg | tail -1 [237413.117757] assign_0x1_p1[353]: segfault at 41414141 ip 0000000041414141 sp 00000000ff92aef0 error 14 in libc-2.24.so[f7578000+1b3000] running gdb $ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA > input $ gdb ./assign_0x1_p1 > run <input Starting program: ./assign_0x1_p1 <input CS6332 Crackme Level 0x00 Password: Invalid Password! Program received signal SIGSEGV, Segmentation fault. 0x41414141 in ?? ()","title":"Description"},{"location":"assignment01/#control-eip","text":"Let\u2019s figure out which input tainted the instruction pointer. $ echo AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHHIIIIJJJJ > input $ ./assign_0x1_p1 <input $ dmesg | tail -1 [238584.915883] assign_0x1_p1[1095]: segfault at 48484848 ip 0000000048484848 sp 00000000ffc32f80 error 14 in libc-2.24.s What\u2019s the current instruction pointer? You might need this help: $ man ascii You can also figure out the exact shape of the stack frame by looking at the instructions as well. $ r2 assign_0x1_p1 ... 8048414: 55 push %ebp 8048415: 89 e5 mov %esp,%ebp 8048417: 83 ec 28 sub $0x28,%esp ... 8048448: 8d 45 e8 lea -0x18(%ebp),%eax 804844b: 89 44 24 04 mov %eax,0x4(%esp) 804844f: c7 04 24 8c 85 04 08 movl $0x804858c,(%esp) 8048456: e8 d5 fe ff ff call 8048330 <scanf@plt> ... Note Successful control hijack will eventually run system(\u201c/home/assign_0x1_p1/solve\u201d) ! Look inside the binary! The following is the disassembly of assign_0x1_p1 binary. $ r2 assign_0x1_p1 .... \u250c (fcn) main 136 .... \u2502 0x080485c2 e809feffff sym.imp.strcmp () ; int strcmp(const char *s1, const char *s2) \u2502 0x080485c7 83c408 esp += 8 \u2502 0x080485ca 85c0 var = eax & eax \u2502 \u250c\u2500< 0x080485cc 751c if (var) goto 0x80485ea \u2502 \u2502 0x080485ce 68ac860408 push str.Password_OK_: ; 0x80486ac ; \"Password OK :)\" \u2502 \u2502 0x080485d3 e838feffff sym.imp.puts () ; int puts(const char *s) \u2502 \u2502 0x080485d8 83c404 esp += 4 \u2502 \u2502 0x080485db 68bb860408 push str.home_assign_0x1_p1_solve ; 0x80486bb ; \"/home/assign_0x1_p1/solve\" \u2502 \u2502 0x080485e0 e83bfeffff sym.imp.system () ; int system(const char *string) \u2502 \u2502 0x080485e5 83c404 esp += 4 \u2502 \u250c\u2500\u2500< 0x080485e8 eb0d goto 0x80485f7 \u2502 \u2502\u2502 ; JMP XREF from 0x080485cc (main) \u2502 \u2502\u2514\u2500> 0x080485ea 68d5860408 push str.Invalid_Password ; 0x80486d5 ; \"Invalid Password!\" \u2502 \u2502 0x080485ef e81cfeffff sym.imp.puts () ; int puts(const char *s) \u2502 \u2502 0x080485f4 83c404 esp += 4 \u2502 \u2502 ; JMP XREF from 0x080485e8 (main) \u2502 \u2514\u2500\u2500> 0x080485f7 b800000000 eax = 0 \u2502 0x080485fc c9 \u2514 0x080485fd c3 return 0","title":"Control EIP"},{"location":"assignment01/#output-to-submit","text":"Save your attack payload to input1 . The expected running example would be like the following. $ cat input1 | ./assign_0x1_p1 CS6332 Crackme Level 00 Password: Invalid Password! Password OK :) Segmentation fault","title":"Output to submit"},{"location":"assignment01/#part-2-8-point-return-to-libc","text":"","title":"Part 2 (8 point): Return-to-libc"},{"location":"assignment01/#preparation_1","text":"For this part, we will use assign_0x1_p1 binary again. Download assign_0x1_p1 from http://cs6332.syssec.org/crackmes/assign_0x1_p1 and check its binary to ensure stack section ( GNU_STACK ) is in RW permission which mean you can overwrite a stack, but cannot run any code from there. $ readelf -W -l ./assign_0x1_p2|grep STACK GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4","title":"Preparation"},{"location":"assignment01/#description_1","text":"From this part of the assignment, you can still hijack the control by overwriting the return address, but you don\u2019t know where to transfer the control, to run the desired command (say /bin/sh ). In this part of the assignment, we want to use system() function provided by Glibc library. For its usage, please check out man -s 3 system . Please write an input that would overwrite the address of system() to return address of main() and transfer the control aa main() function returns. Don\u2019t forget to find a way to pass a string of command that you want to run ( /bin/sh ) as the first function argument to system() function. You can provide it from your stack or you can simply search for the string from Glibc.","title":"Description"},{"location":"assignment01/#system-function-example","text":"The above snippet would give you a command prompt. $ cat << EOF > /tmp/system.c #include <stdlib.h> // system.c int main() { system(\"/bin/sh\"); } EOF $ gcc /tmp/system.c $ ./a.out $ whoami kjee","title":"system() function example"},{"location":"assignment01/#getting-addresses-of-necessary-ingredients","text":"GDB (Peda) will the address of system() at runtime. $ gdb assign_0x1_p2 gdb-peda$ b main gdb-peda$ run ... gdb-peda$ print system $1 = {<text variable, no debug info>} 0xf7e26d10 <system> 0xf7e26d10 is address that you want to return to run the function.","title":"Getting addresses of necessary ingredients."},{"location":"assignment01/#output-to-submit_1","text":"Save your attack payload to input2 . The expected running example would be like the following. You will pretend env -i , so as for the stack layout to be more deterministic. $ cat input2 | env -i ./assign_0x1_p2 CS6332 Crackme Level 00 Password: Invalid Password! .... $ sh ./solve ....","title":"Output to submit"},{"location":"assignment01/#part-3-8-piont-jump-to-your-own-shellcode","text":"","title":"Part 3 (8 piont): Jump to your own shellcode"},{"location":"assignment01/#preparation_2","text":"Download assign_0x1_p3 from http://cs6332.syssec.org/crackmes/assign_0x1_p3 and check its binary to ensure stack section ( GNU_STACK ) is in RWE permission which mean you can write and run a shellcode snippet from stack. $ readelf -W -l ./assign_0x1_p3|grep STACK GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x10","title":"Preparation"},{"location":"assignment01/#description_2","text":"From this assignment, PEDA will generate a shellcode. You will craft an input to overwrite the stack with shellcode and transfer control the beginning of shellcode as main() function returns. You can google for execve() shellcode x86 that would eventually run /bin/sh command for you. Check shellcode length, and make sure shellcode should fit in to stack. Let\u2019s see we have enough space in stack. $ objdump -j .text -d assign_0x1_p3 ... 5bc: 83 ec 20 sub $0x30,%esp ... Create an input that would run shellcode and subsequently give /bin/sh prompt. Please note that different lengths of environment variables + arguments can also vary the resulting stack address widely from computer to computer. A way to mitigate this issue is doing a NOP slide (see https://old.liveoverflow.com/binary_hacking/protostar/stack5.html).","title":"Description"},{"location":"assignment01/#output-to-submit_2","text":"Save your attack payload to input2 . The expected running example would be like the following. You will pretend env -i , so as for stack layout to be more deterministic. $ cat input3 | env -i ./assign_0x1_p3 CS6332 Crackme Level 00 Password: Invalid Password! ... $ sh ./solve ....","title":"Output to submit"},{"location":"assignment01/#submission","text":"Submit a file with following entries. NetID: <Your NetID> * Part 1 <hash from /home/assign_0x1_p1/solve> * Part 2 <hash from /home/assign_0x1_p2/solve> * Part 3 <hash from /home/assign_0x1_p3/solve> [Credit] : Henry Wang has significantly contributed to improve the assignment. Page last revised on: 2019-09-20","title":"Submission"},{"location":"assignments/","text":"Assignments Assignment 1 Assignment 2 Assignment 3 Page last revised on: 2019-09-02","title":"Assignments"},{"location":"assignments/#assignments","text":"","title":"Assignments"},{"location":"assignments/#assignment-1","text":"","title":"Assignment 1"},{"location":"assignments/#assignment-2","text":"","title":"Assignment 2"},{"location":"assignments/#assignment-3","text":"Page last revised on: 2019-09-02","title":"Assignment 3"},{"location":"general/","text":"Course Information Instructor Instructor: Kangkook Jee ( firstname . lastname @utdallas.edu) Office ECSS 3.226 Office hour: 3:00 ~ 4:30 PM Friday Course links Course website: http://www.syssec.org/cs6332-F19/ Coursebook: https://coursebook.utdallas.edu/search/cs6332.001.19f eLearning: Class meetings When: F 15:05-17:45 (3:05pm-5:45pm) Where: ECSN 2.120 Course Description CS 6332 is a graduate-level, research-oriented, systems, and software, security class. The course mainly focus on security issues on system and software programs. Therefore the course will cover The basics concepts regarding the system and program, Attacker tactics and techniques to take over software systems, Countering security measures to monitor, analyze, and mitigate variety sets of security security issues. Learning expectations Through this course, students will learn Basics of computer system and software systems with special stress on initialization and its subsequent program executions. Students will learn the variety of attacker tactics and techniques evolve over time to exploit security holes along with counterpart defense mechanisms. Different reverse engineering techniques to monitor, analyze, and mitigate (both benign and malicious) program activities which would include secure system design principles; dynamic and static analysis approaches for different program representation \u2013 source code, binary, compiler IR, and byte-codes; VMM (hypervisor) techniques to instrument runtime process. Course pre-requisites CS 3340: Computer Architecture ; CS 3377: C Programming in a UNIX Environment ; CS 4348 - Operating Systems Concepts Recommended courses CS 6301: Language-based Security ; CS 4393: Computer and Network Security ; CS 6349.001: Network Security Suggested Texts, Readings, & Materials The course has no textbook, but assigned readings from different sources (refer to course schedule). The followings are recommended readings for the class. [AOE] Erickson, Jon. \u201cHacking: The Art of Exploitation\u201d, 2nd Edition. [SRE] Eldad Eilam. \u201cReversing: Secrets of Reverse Engineering\u201d. [CSAPP] Randal E. Bryant and David R. O\u2019Hallaron. \u201cComputer Systems: A Programmer\u2019s Perspective\u201d 2nd Edition. [TSH] Kozoil, Jack. \u201cThe Shellcoder\u2019s Handbook: Discovering and Exploiting Security Holes\u201d. [PPA] Principles in Program Analysis. Springer. TAs TA: [TBD] Email: cs6332staff@utdallas.edu Online discussion Online discussion is strongly encouraged and it will help you a lot in solving lab problems. Please join Piazza and post your questions, ideas and thoughts. Page last revised on: 2019-08-27","title":"General"},{"location":"general/#course-information","text":"","title":"Course Information"},{"location":"general/#instructor","text":"Instructor: Kangkook Jee ( firstname . lastname @utdallas.edu) Office ECSS 3.226 Office hour: 3:00 ~ 4:30 PM Friday","title":"Instructor"},{"location":"general/#course-links","text":"Course website: http://www.syssec.org/cs6332-F19/ Coursebook: https://coursebook.utdallas.edu/search/cs6332.001.19f eLearning:","title":"Course links"},{"location":"general/#class-meetings","text":"When: F 15:05-17:45 (3:05pm-5:45pm) Where: ECSN 2.120","title":"Class meetings"},{"location":"general/#course-description","text":"CS 6332 is a graduate-level, research-oriented, systems, and software, security class. The course mainly focus on security issues on system and software programs. Therefore the course will cover The basics concepts regarding the system and program, Attacker tactics and techniques to take over software systems, Countering security measures to monitor, analyze, and mitigate variety sets of security security issues.","title":"Course Description"},{"location":"general/#learning-expectations","text":"Through this course, students will learn Basics of computer system and software systems with special stress on initialization and its subsequent program executions. Students will learn the variety of attacker tactics and techniques evolve over time to exploit security holes along with counterpart defense mechanisms. Different reverse engineering techniques to monitor, analyze, and mitigate (both benign and malicious) program activities which would include secure system design principles; dynamic and static analysis approaches for different program representation \u2013 source code, binary, compiler IR, and byte-codes; VMM (hypervisor) techniques to instrument runtime process.","title":"Learning expectations"},{"location":"general/#course-pre-requisites","text":"CS 3340: Computer Architecture ; CS 3377: C Programming in a UNIX Environment ; CS 4348 - Operating Systems Concepts","title":"Course pre-requisites"},{"location":"general/#recommended-courses","text":"CS 6301: Language-based Security ; CS 4393: Computer and Network Security ; CS 6349.001: Network Security","title":"Recommended courses"},{"location":"general/#suggested-texts-readings-materials","text":"The course has no textbook, but assigned readings from different sources (refer to course schedule). The followings are recommended readings for the class. [AOE] Erickson, Jon. \u201cHacking: The Art of Exploitation\u201d, 2nd Edition. [SRE] Eldad Eilam. \u201cReversing: Secrets of Reverse Engineering\u201d. [CSAPP] Randal E. Bryant and David R. O\u2019Hallaron. \u201cComputer Systems: A Programmer\u2019s Perspective\u201d 2nd Edition. [TSH] Kozoil, Jack. \u201cThe Shellcoder\u2019s Handbook: Discovering and Exploiting Security Holes\u201d. [PPA] Principles in Program Analysis. Springer.","title":"Suggested Texts, Readings, &amp; Materials"},{"location":"general/#tas","text":"TA: [TBD] Email: cs6332staff@utdallas.edu","title":"TAs"},{"location":"general/#online-discussion","text":"Online discussion is strongly encouraged and it will help you a lot in solving lab problems. Please join Piazza and post your questions, ideas and thoughts. Page last revised on: 2019-08-27","title":"Online discussion"},{"location":"inc/","text":"test.include","title":"test.include"},{"location":"inc/#testinclude","text":"","title":"test.include"},{"location":"papers/","text":"Reading list Note Particularly for systems security papers: (1) Read Abstract \u2192 Introduction \u2192 Conclusion. (2) Find and read a motivation (representative) example or case studies. They include a complete (and often realistic) story and how the proposed idea solves the problem with newly proposed methods. TIP : How to read academic papers Memory Corruption and Control Flow Hijacking SoK: Eternal War in Memory Smashing the Stack : Read the following two articles Smashing the Stack for Fun and Profit Smashing the Stack in 2011 On the effectiveness of Address-Space Randomization [CCS 04] ROP Attacks Return-Oriented Programming: Systems, Languages, and Applications [TISSEC 12] Return-oriented programming without returns [CCS 12] You Can Run but You Can\u2019t Read: Preventing Disclosure Exploits in Executable Code [CCS 14] Readactor: Practical Code Randomization Resilient to Memory Disclosure [SP 15] Control Flow and Code Pointer Integrity Control-Flow Integrity [CCS 05] Control Flow Integrity for COTS Binaries [SEC 13] Code-Pointer Integrity [OSDI 2014] More Binary Attack and Defenses Advanced Attacks Framing Signals\u2014A Return to Portable Shellcode APISAn: Sanitizing API Usages through Semantic Cross-Checking (State of) The Art of War: Offensive Techniques in Binary Analysis Integer Vulnerabilities and Defenses Understanding Integer Overflow in C/C++ [ICSE 2012] Improving Integer Security for Systems with KINT [OSDI 12] Dynamic/Static Analysis Frameworks Pin: building customized program analysis tools with dynamic instrumentation [PLDI 05] Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation [PLDI 07] LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation [CGO\u201804] DynInst Anywhere, any-time binary instrumentation [PASTE 11] AddressSanitizer: A Fast Address Sanity Checker [ATC 12] Dynamic Analysis libdft: Practical Dynamic Data Flow Tracking for Commodity Systems [VEE 12] A General Approach for Efficiently Accelerating Software-based Dynamic Data Flow Tracking on Commodity Hardware [NDSS 12] FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint Analysis for Android Apps [PLDI 14] LDX: Causality Inference by Lightweight Dual Execution [ASPLOS 16] Static Analysis Compiler-assisted Code Randomization [SP 18] Symbolic Execution KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs [OSDI 08] (State of) The Art of War: Offensive Techniques in Binary Analysis [SP 16] Virtualization and Security When Virtual is Harder than Real: Security Challenges in Virtual Machine Based Computing Environments [HotOS 05] Virtualization: Issues, Security Threats, and Solutions CloudVisor: Retrofitting Protection of Virtual Machines in Multi-tenant Cloud with Nested Virtualization [SOSP 11] Hey, You, Get Off of My Cloud: Exploring Information Leakage in Third-Party Compute Clouds [CCS 09] Kernel security Linux kernel vulnerabilities: State-of-the-art defenses and open problems short paper ret2dir: Rethinking Kernel Isolation [SEC 14] Breaking Kernel Address Space Layout Randomization with Intel TSX [CCS 16] Sandboxing: Isolation, and Fault localization The Security Architecture of the Chromium Browser Native Client: A Sandbox for Portable, Untrusted x86 Native Code [S&P 09] Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts [SP 17] IoT and CPS Security GUITAR: Piecing Together Android App GUIs from Memory Images [CCS 15] Fear and Logging in the Internet of Things [NDSS 18] IoTFuzzer: Discovering Memory Corruptions in IoT Through App-based Fuzzing [NDSS 18] Sensitive Information Tracking in Commodity IoT [SEC 18] Stuxnet: Dissecting a Cyberwarfare Weapon [SP 11] Revealed: How a secret Dutch mole aided the U.S.-Israeli Stuxnet cyberattack on Iran [News article] Threat Intelligence Computing Threat Intelligence Computing [CCS 18] Reading the Tea leaves: A Comparative Analysis of Threat Intelligence [SEC 19] Understanding and Securing Device Vulnerabilities through Automated Bug Report Analysis [SEC 19] ATTACK2VEC: Leveraging Temporal Word Embeddings to Understand the Evolution of Cyberattacks [SEC 19] Audit-logging and Provenance Analysis Traps and Pitfalls: Practical Problems in System Call Interposition Based Security Tools [NDSS 03] LogGC: Garbage Collecting Audit Log [CCS 13] Towards a Timely Causality Analysis for Enterprise Security [NDSS 18] Code obfuscation/de-obfuscation SoK: Deep Packer Inspection: A Longitudinal Study of the Complexity of Run-Time Packers [SP 15] Deobfuscation of virtualization-obfuscated software: a semantics-based approach [CCS\u201811] LOOP: Logic-Oriented Opaque Predicate Detection in Obfuscated Binary Code [CCS\u201815] Code obfuscation against symbolic execution attacks [ACSAC\u201816] Hardwares Hardware Vulnerabilities - Cases for Meltdown / Spectre Attacks Meltdown: Reading Kernel Memory from User Space [Sec 18] Spectre Attacks: Exploiting Speculative Execution [S&P 19] Hardware and Enclave (SGX) Security Inferring Fine-grained Control Flow Inside SGX Enclaves with Branch Shadowing [SEC 17] High-Resolution Side Channels for Untrusted Operating Systems [ATC 17] Graphene-SGX: A Practical Library OS for Unmodified Applications on SGX [ATC 17] Page last revised on: 2019-09-06","title":"Papers"},{"location":"papers/#reading-list","text":"Note Particularly for systems security papers: (1) Read Abstract \u2192 Introduction \u2192 Conclusion. (2) Find and read a motivation (representative) example or case studies. They include a complete (and often realistic) story and how the proposed idea solves the problem with newly proposed methods. TIP : How to read academic papers","title":"Reading list"},{"location":"papers/#memory-corruption-and-control-flow-hijacking","text":"SoK: Eternal War in Memory Smashing the Stack : Read the following two articles Smashing the Stack for Fun and Profit Smashing the Stack in 2011 On the effectiveness of Address-Space Randomization [CCS 04]","title":"Memory Corruption and Control Flow Hijacking"},{"location":"papers/#rop-attacks","text":"Return-Oriented Programming: Systems, Languages, and Applications [TISSEC 12] Return-oriented programming without returns [CCS 12] You Can Run but You Can\u2019t Read: Preventing Disclosure Exploits in Executable Code [CCS 14] Readactor: Practical Code Randomization Resilient to Memory Disclosure [SP 15]","title":"ROP Attacks"},{"location":"papers/#control-flow-and-code-pointer-integrity","text":"Control-Flow Integrity [CCS 05] Control Flow Integrity for COTS Binaries [SEC 13] Code-Pointer Integrity [OSDI 2014]","title":"Control Flow and Code Pointer Integrity"},{"location":"papers/#more-binary-attack-and-defenses","text":"","title":"More Binary Attack and Defenses"},{"location":"papers/#advanced-attacks","text":"Framing Signals\u2014A Return to Portable Shellcode APISAn: Sanitizing API Usages through Semantic Cross-Checking (State of) The Art of War: Offensive Techniques in Binary Analysis","title":"Advanced Attacks"},{"location":"papers/#integer-vulnerabilities-and-defenses","text":"Understanding Integer Overflow in C/C++ [ICSE 2012] Improving Integer Security for Systems with KINT [OSDI 12]","title":"Integer Vulnerabilities and Defenses"},{"location":"papers/#dynamicstatic-analysis-frameworks","text":"Pin: building customized program analysis tools with dynamic instrumentation [PLDI 05] Valgrind: A Framework for Heavyweight Dynamic Binary Instrumentation [PLDI 07] LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation [CGO\u201804] DynInst Anywhere, any-time binary instrumentation [PASTE 11] AddressSanitizer: A Fast Address Sanity Checker [ATC 12]","title":"Dynamic/Static Analysis Frameworks"},{"location":"papers/#dynamic-analysis","text":"libdft: Practical Dynamic Data Flow Tracking for Commodity Systems [VEE 12] A General Approach for Efficiently Accelerating Software-based Dynamic Data Flow Tracking on Commodity Hardware [NDSS 12] FlowDroid: Precise Context, Flow, Field, Object-sensitive and Lifecycle-aware Taint Analysis for Android Apps [PLDI 14] LDX: Causality Inference by Lightweight Dual Execution [ASPLOS 16]","title":"Dynamic Analysis"},{"location":"papers/#static-analysis","text":"Compiler-assisted Code Randomization [SP 18]","title":"Static Analysis"},{"location":"papers/#symbolic-execution","text":"KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs [OSDI 08] (State of) The Art of War: Offensive Techniques in Binary Analysis [SP 16]","title":"Symbolic Execution"},{"location":"papers/#virtualization-and-security","text":"When Virtual is Harder than Real: Security Challenges in Virtual Machine Based Computing Environments [HotOS 05] Virtualization: Issues, Security Threats, and Solutions CloudVisor: Retrofitting Protection of Virtual Machines in Multi-tenant Cloud with Nested Virtualization [SOSP 11] Hey, You, Get Off of My Cloud: Exploring Information Leakage in Third-Party Compute Clouds [CCS 09]","title":"Virtualization and Security"},{"location":"papers/#kernel-security","text":"Linux kernel vulnerabilities: State-of-the-art defenses and open problems short paper ret2dir: Rethinking Kernel Isolation [SEC 14] Breaking Kernel Address Space Layout Randomization with Intel TSX [CCS 16]","title":"Kernel security"},{"location":"papers/#sandboxing-isolation-and-fault-localization","text":"The Security Architecture of the Chromium Browser Native Client: A Sandbox for Portable, Untrusted x86 Native Code [S&P 09] Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts [SP 17]","title":"Sandboxing: Isolation, and Fault localization"},{"location":"papers/#iot-and-cps-security","text":"GUITAR: Piecing Together Android App GUIs from Memory Images [CCS 15] Fear and Logging in the Internet of Things [NDSS 18] IoTFuzzer: Discovering Memory Corruptions in IoT Through App-based Fuzzing [NDSS 18] Sensitive Information Tracking in Commodity IoT [SEC 18] Stuxnet: Dissecting a Cyberwarfare Weapon [SP 11] Revealed: How a secret Dutch mole aided the U.S.-Israeli Stuxnet cyberattack on Iran [News article]","title":"IoT and CPS Security"},{"location":"papers/#threat-intelligence-computing","text":"Threat Intelligence Computing [CCS 18] Reading the Tea leaves: A Comparative Analysis of Threat Intelligence [SEC 19] Understanding and Securing Device Vulnerabilities through Automated Bug Report Analysis [SEC 19] ATTACK2VEC: Leveraging Temporal Word Embeddings to Understand the Evolution of Cyberattacks [SEC 19]","title":"Threat Intelligence Computing"},{"location":"papers/#audit-logging-and-provenance-analysis","text":"Traps and Pitfalls: Practical Problems in System Call Interposition Based Security Tools [NDSS 03] LogGC: Garbage Collecting Audit Log [CCS 13] Towards a Timely Causality Analysis for Enterprise Security [NDSS 18]","title":"Audit-logging and Provenance Analysis"},{"location":"papers/#code-obfuscationde-obfuscation","text":"SoK: Deep Packer Inspection: A Longitudinal Study of the Complexity of Run-Time Packers [SP 15] Deobfuscation of virtualization-obfuscated software: a semantics-based approach [CCS\u201811] LOOP: Logic-Oriented Opaque Predicate Detection in Obfuscated Binary Code [CCS\u201815] Code obfuscation against symbolic execution attacks [ACSAC\u201816]","title":"Code obfuscation/de-obfuscation"},{"location":"papers/#hardwares","text":"","title":"Hardwares"},{"location":"papers/#hardware-vulnerabilities-cases-for-meltdown-spectre-attacks","text":"Meltdown: Reading Kernel Memory from User Space [Sec 18] Spectre Attacks: Exploiting Speculative Execution [S&P 19]","title":"Hardware Vulnerabilities - Cases for Meltdown / Spectre Attacks"},{"location":"papers/#hardware-and-enclave-sgx-security","text":"Inferring Fine-grained Control Flow Inside SGX Enclaves with Branch Shadowing [SEC 17] High-Resolution Side Channels for Untrusted Operating Systems [ATC 17] Graphene-SGX: A Practical Library OS for Unmodified Applications on SGX [ATC 17] Page last revised on: 2019-09-06","title":"Hardware and Enclave (SGX) Security"},{"location":"projdraft/","text":"System call level data collection for behavioral security analysis Motivation In implementing in-host (vs. out-host or network) security measures efficient and reliable source for data collection is an essential building block. While different design choices are available in terms of monitoring granularities, system call level monitoring seems to be reasonable compromise consideration in terms of performance overhead and monitoring accuracy (granularity). Many existing in-host monitoring solutions choose a subset of system calls to capture, monitor and report for security analysis. Can we implement a better data collection for system call tracing? Leveraging the existing system call collection mechanisms (say sysdig, or dtrace, linux audit), how much overhead that we expect? can we collect and This area is in large demand and can spun into a number of different research directions. Project idea 1: System-call level data collection framework for Windows A number of existing implementation exists for Linux systems (Linux Audit, OSX DTrace, Sysdig project), but not many implementation exists for Windows operating systems. The main purpose of the project will be implementing MS Windows version of system call level data collection framework. Students will study and investigate a cadidate data source ETW (Event Tracing for Windows) . Students with previous experience MS Windows system programming may find this project interesting. Project idea 2: A comparision study of different system call data collection frameworks Project can start by Data collection implemented/configured to collection the same subset of system calls (e.g., read(), write(), exec(), fork(), send(), recve()) and run those against standardized workload (e.g., benchmark suites and workloads). Project idea 3: User-level support for process-DNS query association Besides system call entries which can be obtained by the above mentioned data sources, we have other interested system events with higher/more security implications worth collected and analyzed. DNS is one of those information, traditionally collected from outside the host, only to associated to the host level without having the finer association with regard to a process which process actually initiated the DNS query of our interestes. A previous of previous proposal exists leveraging kernel level association or system interfaces. These turn out to be too intrusive enforcing users to kernel modules or to be subject to unexpected changes of system implementation. The project will implement the process-DNS association much lighter fashion without loosing/sacrifing the accuracy, but associating and cor-relating network system call (i.e., send(), recv()) and PCAP data. With this project aim to bridge the gap between two different domains of network and system security. Project idea 4: TPM leveraged Integrity and Safety Assurance for Edge Data Collection Agent In implementing host-based security solutions, the guarantee for integrity of data collection agent and trustworthiness of its report have always been a challenging problem. For instance, the security analyst from Security Operation Center (SoC) does not have many options to confirm reports from end-devices (e.g., computers, servers, IoT devices) are indeed genunie (uncompromised). In this project, we want to leverage the hardware encoded security to build a root of trust for end-host security monitoring agents and confirm the authenticity and integrity of its status and messages it is reporting. From the project, students will Investigate and study threat model for end-host security agent. Inverstigate the capability and limitation of generally used TPM devices. Design and propose different level of security design and their trade-offs. Build prototype for TPM leveraged data collection agent Binary Similarity Analysis to Detect Supply Chain Attack Newly updated programs may contain security backdoor. Without source code in hand can we measure the difference and specify the changes made to the code? Students can compare binaries of different versions program analysis representation such Control-Flow Graph (CFG), Function call graph. Such feature may provide an important and useful primitive detecting and mitigating the latest threats such as supply-chain-attacks . Many different ways for such attacks to be implanted to a public and well-trusted sources. The software vendor may implant attack vectors to get capabilities beyond its users expectation pretending it to be as a mere functionality extension. Or the active attacker plays a hat of open source programer and contribute to a widely adopted projects pretending to be a simple functionality extensions. Project steps Literature survey Impelement your own prototype example Choose a not-to-big but interesting open source project Build the source to produce a bianry. Extract program representation against the binary. Inject a threat vector(e.g., simple backdoor) Build the source to produce a bianry. Extract program representation against the binary. Compare two representations to confirm your approach. Apply your approach to real softwares You can test your approach with .... References Towards Automatic Software Lineage Inference Usenix Security 2013 Edge TPU related project Google and Nvidia deployed edge-based computing devices for accelerating machine learning workloads. Nvidia Jetson nano Google Edge TPU processing board The motivation behind the direction is to offload expensive tasks of data transfer to the cloud and processing to on-the-spot edge devices. While this open a new computational model and further facilitates new usage cases with the various applications based on accelerated ML support on-the-fly, at the same time it can also bring new security landscapes eitherproviding new ways of implementing security task or exposing new attack surface for the adversaries can aim to take over. Project idea 1: Security application using Edge-TPU With new device and its new capability, students can be wild and creative to propose a new security application. Note that image and video at the edge devices (similar size of Raspberry Pi board) will have much larger throughout and performed much faster. Project idea 2: Protecting assets from Edge-TPU With new edge device, important intellectual assets such as Prediction Model needs to be offloaded and transferred to each edge devices. For the portablity nature of Edge device, adversary can easily obtain devices phsycally or over the network. For the project, students can think of ways to prevent such assets from being taken over by the adversary. Students needs to consider both runtime and offline aspects. Note that CPU components of the devices by default Trustzone featuress. Improvement for Automated Large-scale Malware Analysis Study Recently, we observe millions of allegedly payloads are found and reported daily and this phenomenon pushes the task of manual investigation and analysis nearly infeasilble. Industry and academia together have proposed and worked on automated framework to scale process and analyze malware payloads by implemented automated security sandbox for security and malware analysis. Yet, such proposal has improved the status, we as a community yet to see many pitfalls and limitation in replaying malware and capture the essence of malicious behavior. From this project, students will perform the following tasks. First implement one of the most well-known opensource sandbox for malware analysis . Write behavioral signature by extending a Cuckoo community API to better judge whethter a given payload is indeed malicous thus require further investigation. Investigate different techniques (Anti-VM, Anti-Debug) that give malware writers employs to probes the sandbox execution to silencing any of malicious behaviors, thus can remain undetected/undiscovered by the analysis. For a given malware payload, extend the sandbox framework by implementing functionalities to spot anti-debugging techinques and find a way to go around it. References Cuckoo Sandbox Cuckoo Community Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts Implementation of Advanced Persitent Threat (APT) framework for Security Evaluation More research and industry together focuses on Advanced Persistent Threat (APT) designed and launched by nation-level threat actors. Different approaches to monitor, analyze, and mitigate such attacks are proposed. However, research and industry together lacks in framework level support for testing and confirm their effectiveness in protecting valuable assets against such attempts. In this project, students will First, perform a literature research APT attacks. Build a mini-lab environment that would emulate a real-world enterprise environment. Implement and document a number of APT cases References APT Notes - Github project: new repo , old repo APT3 scenario by MITRE Steganography or image forensics \u2013 Analysis and defense for malcious payload embedded documentation Steganography has been an effective techinques for the hacker community in embedding different types of malcious payloads into seemingly benign document to evade security detection measures. This provides attacker easy way to propagated their malicious payloads yet remain undetected by any security measure. When you see any databases or public resources for malware collections, you realizes malware-embedded documents now take majority. Analyzing Malicious Documents Cheat Sheet https://www.youtube.com/watch?v=np0mPy-EHII Steganography: A Safe Haven for Malware https://books.google.com/books?hl=en&lr=&id=qMB9AiFUWF0C&oi=fnd&pg=PP1&ots=glBaUv19cd&sig=VrUI34kRvs67Lf7r7EMHNRbBtz0 \u2018Dresden Image Database\u2019 for benchmarking digital image forensics Comparsion of process-level instrumentation approachs virtualization As our course proceeds, we will learn a number of different choices in instrumenting software program to introspect process and system internals at runtime. The one can leverage such frameworks to monitor, analyze, and mitigate process and system activities. Instrumentation frameworks Binary re-writing: DynInst Process-level: PIN , Valgrind , DynamoRIO System-level: QEmu While we have different options and frameworks in implemening such meastures, design options and its trade-offs are not fully explored by the literatures. For this project, students will First, study and understand different instrumentation frameworks Implement security/program analysis using the framework E.g., Control Flow Graph generator Define a standard workload to run and measure overhead, and usability. Resources Pin project , Pin paper DynamoRio project , DynamoRio paper Valgrind project , Valgrind paper QEmu project , QEmu paper DynInst project , DynInst paper Automated IOC processing to produce actionable security rules Indicator of Compromise (IOC) indicates an artifact observed on a network or in an operating system that, with high confidence, indicates a computer intrusion. While IOC transforms the game security by cultivating the smooth exchange of security indicators. To further facilitates security information exchange by addressing the complexity and hectic nature of such security information that we have observed with the existing protocol (e.g., Yara rules ), a number of different standards are proposed and work on progress ( STIX , TAXI ). While these proposals attempt to address large portion of problem domain, still we have non-negligible rooms remain for improvements, for instance, many of important security IOCs are posted in a hard to parse not confirming to Internet standard. For instance, many security analysis are written in a plain English in a form of technical report, whitepaper, or blog postings. From this project, student will attempts to parse malformed security indicators into STIX or TAXI conpatiable formation, so as it can be properly translated into standard IOC format and further circulated. Conntrack Visualizer Bridging Threat Intelligence Leveraging Cuckoo environment Between network and system domains While one threat intelligence matches, how about another? Does how credibility/trust propagate across different domains? We may run this from Cuckoo sandbox User level process-DNS correlation For Windows and Linux Efficient and Complete IPC monitoring mechanism Project idea 4: TPM leveraged Integrity and Safety Assurance for Edge Data Collection Agent In implementing host-based security solutions, the guarantee for integrity of data collection agent and trustworthiness of its report have always been a challenging problem. For instance, the security analyst from Security Operation Center (SoC) does not have many options to confirm reports from end-devices (e.g., computers, servers, IoT devices) are indeed genunie (uncompromised). In this project, we want to leverage the hardware encoded security to build a root of trust for end-host security monitoring agents and confirm the authenticity and integrity of its status and messages it is reporting. From the project, students will Investigate and study threat model for end-host security agent. Inverstigate the capability and limitation of generally used TPM devices. Design and propose different level of security design and their trade-offs. Build prototype for TPM leveraged data collection agent Page last revised on: 2019-09-13","title":"Projdraft"},{"location":"projdraft/#system-call-level-data-collection-for-behavioral-security-analysis","text":"","title":"System call level data collection for behavioral security analysis"},{"location":"projdraft/#motivation","text":"In implementing in-host (vs. out-host or network) security measures efficient and reliable source for data collection is an essential building block. While different design choices are available in terms of monitoring granularities, system call level monitoring seems to be reasonable compromise consideration in terms of performance overhead and monitoring accuracy (granularity). Many existing in-host monitoring solutions choose a subset of system calls to capture, monitor and report for security analysis. Can we implement a better data collection for system call tracing? Leveraging the existing system call collection mechanisms (say sysdig, or dtrace, linux audit), how much overhead that we expect? can we collect and This area is in large demand and can spun into a number of different research directions.","title":"Motivation"},{"location":"projdraft/#project-idea-1-system-call-level-data-collection-framework-for-windows","text":"A number of existing implementation exists for Linux systems (Linux Audit, OSX DTrace, Sysdig project), but not many implementation exists for Windows operating systems. The main purpose of the project will be implementing MS Windows version of system call level data collection framework. Students will study and investigate a cadidate data source ETW (Event Tracing for Windows) . Students with previous experience MS Windows system programming may find this project interesting.","title":"Project idea 1: System-call level data collection framework for Windows"},{"location":"projdraft/#project-idea-2-a-comparision-study-of-different-system-call-data-collection-frameworks","text":"Project can start by Data collection implemented/configured to collection the same subset of system calls (e.g., read(), write(), exec(), fork(), send(), recve()) and run those against standardized workload (e.g., benchmark suites and workloads).","title":"Project idea 2: A comparision study of different system call data collection frameworks"},{"location":"projdraft/#project-idea-3-user-level-support-for-process-dns-query-association","text":"Besides system call entries which can be obtained by the above mentioned data sources, we have other interested system events with higher/more security implications worth collected and analyzed. DNS is one of those information, traditionally collected from outside the host, only to associated to the host level without having the finer association with regard to a process which process actually initiated the DNS query of our interestes. A previous of previous proposal exists leveraging kernel level association or system interfaces. These turn out to be too intrusive enforcing users to kernel modules or to be subject to unexpected changes of system implementation. The project will implement the process-DNS association much lighter fashion without loosing/sacrifing the accuracy, but associating and cor-relating network system call (i.e., send(), recv()) and PCAP data. With this project aim to bridge the gap between two different domains of network and system security.","title":"Project idea 3: User-level support for process-DNS query association"},{"location":"projdraft/#project-idea-4-tpm-leveraged-integrity-and-safety-assurance-for-edge-data-collection-agent","text":"In implementing host-based security solutions, the guarantee for integrity of data collection agent and trustworthiness of its report have always been a challenging problem. For instance, the security analyst from Security Operation Center (SoC) does not have many options to confirm reports from end-devices (e.g., computers, servers, IoT devices) are indeed genunie (uncompromised). In this project, we want to leverage the hardware encoded security to build a root of trust for end-host security monitoring agents and confirm the authenticity and integrity of its status and messages it is reporting. From the project, students will Investigate and study threat model for end-host security agent. Inverstigate the capability and limitation of generally used TPM devices. Design and propose different level of security design and their trade-offs. Build prototype for TPM leveraged data collection agent","title":"Project idea 4: TPM leveraged Integrity and Safety Assurance for Edge Data Collection Agent"},{"location":"projdraft/#binary-similarity-analysis-to-detect-supply-chain-attack","text":"Newly updated programs may contain security backdoor. Without source code in hand can we measure the difference and specify the changes made to the code? Students can compare binaries of different versions program analysis representation such Control-Flow Graph (CFG), Function call graph. Such feature may provide an important and useful primitive detecting and mitigating the latest threats such as supply-chain-attacks . Many different ways for such attacks to be implanted to a public and well-trusted sources. The software vendor may implant attack vectors to get capabilities beyond its users expectation pretending it to be as a mere functionality extension. Or the active attacker plays a hat of open source programer and contribute to a widely adopted projects pretending to be a simple functionality extensions.","title":"Binary Similarity Analysis to Detect Supply Chain Attack"},{"location":"projdraft/#project-steps","text":"Literature survey Impelement your own prototype example Choose a not-to-big but interesting open source project Build the source to produce a bianry. Extract program representation against the binary. Inject a threat vector(e.g., simple backdoor) Build the source to produce a bianry. Extract program representation against the binary. Compare two representations to confirm your approach. Apply your approach to real softwares You can test your approach with ....","title":"Project steps"},{"location":"projdraft/#references","text":"Towards Automatic Software Lineage Inference Usenix Security 2013","title":"References"},{"location":"projdraft/#edge-tpu-related-project","text":"Google and Nvidia deployed edge-based computing devices for accelerating machine learning workloads. Nvidia Jetson nano Google Edge TPU processing board The motivation behind the direction is to offload expensive tasks of data transfer to the cloud and processing to on-the-spot edge devices. While this open a new computational model and further facilitates new usage cases with the various applications based on accelerated ML support on-the-fly, at the same time it can also bring new security landscapes eitherproviding new ways of implementing security task or exposing new attack surface for the adversaries can aim to take over.","title":"Edge TPU related project"},{"location":"projdraft/#project-idea-1-security-application-using-edge-tpu","text":"With new device and its new capability, students can be wild and creative to propose a new security application. Note that image and video at the edge devices (similar size of Raspberry Pi board) will have much larger throughout and performed much faster.","title":"Project idea 1: Security application using Edge-TPU"},{"location":"projdraft/#project-idea-2-protecting-assets-from-edge-tpu","text":"With new edge device, important intellectual assets such as Prediction Model needs to be offloaded and transferred to each edge devices. For the portablity nature of Edge device, adversary can easily obtain devices phsycally or over the network. For the project, students can think of ways to prevent such assets from being taken over by the adversary. Students needs to consider both runtime and offline aspects. Note that CPU components of the devices by default Trustzone featuress.","title":"Project idea 2: Protecting assets from Edge-TPU"},{"location":"projdraft/#improvement-for-automated-large-scale-malware-analysis-study","text":"Recently, we observe millions of allegedly payloads are found and reported daily and this phenomenon pushes the task of manual investigation and analysis nearly infeasilble. Industry and academia together have proposed and worked on automated framework to scale process and analyze malware payloads by implemented automated security sandbox for security and malware analysis. Yet, such proposal has improved the status, we as a community yet to see many pitfalls and limitation in replaying malware and capture the essence of malicious behavior. From this project, students will perform the following tasks. First implement one of the most well-known opensource sandbox for malware analysis . Write behavioral signature by extending a Cuckoo community API to better judge whethter a given payload is indeed malicous thus require further investigation. Investigate different techniques (Anti-VM, Anti-Debug) that give malware writers employs to probes the sandbox execution to silencing any of malicious behaviors, thus can remain undetected/undiscovered by the analysis. For a given malware payload, extend the sandbox framework by implementing functionalities to spot anti-debugging techinques and find a way to go around it.","title":"Improvement for Automated Large-scale Malware Analysis Study"},{"location":"projdraft/#references_1","text":"Cuckoo Sandbox Cuckoo Community Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts","title":"References"},{"location":"projdraft/#implementation-of-advanced-persitent-threat-apt-framework-for-security-evaluation","text":"More research and industry together focuses on Advanced Persistent Threat (APT) designed and launched by nation-level threat actors. Different approaches to monitor, analyze, and mitigate such attacks are proposed. However, research and industry together lacks in framework level support for testing and confirm their effectiveness in protecting valuable assets against such attempts. In this project, students will First, perform a literature research APT attacks. Build a mini-lab environment that would emulate a real-world enterprise environment. Implement and document a number of APT cases","title":"Implementation of Advanced Persitent Threat (APT) framework for Security Evaluation"},{"location":"projdraft/#references_2","text":"APT Notes - Github project: new repo , old repo APT3 scenario by MITRE","title":"References"},{"location":"projdraft/#steganography-or-image-forensics-analysis-and-defense-for-malcious-payload-embedded-documentation","text":"Steganography has been an effective techinques for the hacker community in embedding different types of malcious payloads into seemingly benign document to evade security detection measures. This provides attacker easy way to propagated their malicious payloads yet remain undetected by any security measure. When you see any databases or public resources for malware collections, you realizes malware-embedded documents now take majority. Analyzing Malicious Documents Cheat Sheet https://www.youtube.com/watch?v=np0mPy-EHII Steganography: A Safe Haven for Malware https://books.google.com/books?hl=en&lr=&id=qMB9AiFUWF0C&oi=fnd&pg=PP1&ots=glBaUv19cd&sig=VrUI34kRvs67Lf7r7EMHNRbBtz0 \u2018Dresden Image Database\u2019 for benchmarking digital image forensics","title":"Steganography or image forensics -- Analysis and defense for malcious payload embedded documentation"},{"location":"projdraft/#comparsion-of-process-level-instrumentation-approachs-virtualization","text":"As our course proceeds, we will learn a number of different choices in instrumenting software program to introspect process and system internals at runtime. The one can leverage such frameworks to monitor, analyze, and mitigate process and system activities. Instrumentation frameworks Binary re-writing: DynInst Process-level: PIN , Valgrind , DynamoRIO System-level: QEmu While we have different options and frameworks in implemening such meastures, design options and its trade-offs are not fully explored by the literatures. For this project, students will First, study and understand different instrumentation frameworks Implement security/program analysis using the framework E.g., Control Flow Graph generator Define a standard workload to run and measure overhead, and usability.","title":"Comparsion of process-level instrumentation approachs virtualization"},{"location":"projdraft/#resources","text":"Pin project , Pin paper DynamoRio project , DynamoRio paper Valgrind project , Valgrind paper QEmu project , QEmu paper DynInst project , DynInst paper","title":"Resources"},{"location":"projdraft/#automated-ioc-processing-to-produce-actionable-security-rules","text":"Indicator of Compromise (IOC) indicates an artifact observed on a network or in an operating system that, with high confidence, indicates a computer intrusion. While IOC transforms the game security by cultivating the smooth exchange of security indicators. To further facilitates security information exchange by addressing the complexity and hectic nature of such security information that we have observed with the existing protocol (e.g., Yara rules ), a number of different standards are proposed and work on progress ( STIX , TAXI ). While these proposals attempt to address large portion of problem domain, still we have non-negligible rooms remain for improvements, for instance, many of important security IOCs are posted in a hard to parse not confirming to Internet standard. For instance, many security analysis are written in a plain English in a form of technical report, whitepaper, or blog postings. From this project, student will attempts to parse malformed security indicators into STIX or TAXI conpatiable formation, so as it can be properly translated into standard IOC format and further circulated.","title":"Automated IOC processing to produce actionable security rules"},{"location":"projdraft/#conntrack-visualizer","text":"","title":"Conntrack Visualizer"},{"location":"projdraft/#bridging-threat-intelligence","text":"Leveraging Cuckoo environment Between network and system domains While one threat intelligence matches, how about another? Does how credibility/trust propagate across different domains? We may run this from Cuckoo sandbox","title":"Bridging Threat Intelligence"},{"location":"projdraft/#user-level-process-dns-correlation","text":"For Windows and Linux","title":"User level process-DNS correlation"},{"location":"projdraft/#efficient-and-complete-ipc-monitoring-mechanism","text":"","title":"Efficient and Complete IPC monitoring mechanism"},{"location":"projdraft/#project-idea-4-tpm-leveraged-integrity-and-safety-assurance-for-edge-data-collection-agent_1","text":"In implementing host-based security solutions, the guarantee for integrity of data collection agent and trustworthiness of its report have always been a challenging problem. For instance, the security analyst from Security Operation Center (SoC) does not have many options to confirm reports from end-devices (e.g., computers, servers, IoT devices) are indeed genunie (uncompromised). In this project, we want to leverage the hardware encoded security to build a root of trust for end-host security monitoring agents and confirm the authenticity and integrity of its status and messages it is reporting. From the project, students will Investigate and study threat model for end-host security agent. Inverstigate the capability and limitation of generally used TPM devices. Design and propose different level of security design and their trade-offs. Build prototype for TPM leveraged data collection agent Page last revised on: 2019-09-13","title":"Project idea 4: TPM leveraged Integrity and Safety Assurance for Edge Data Collection Agent"},{"location":"projects/","text":"System call level data collection for behavioral security analysis Motivation In modern security scene, many security solutions are based on data collected from each end-host (vs. out-host or perimeter network monitoring). Therefore, it is essential to have an efficient and robust data collection agent at each end-host. Many existing in-host monitoring solutions choose to collect a subset of system calls and their argument for security analysis. Efficient and reliable data collection at end-host is high demand, and provide essential building block data-driven security research. Therefore, it brings in a number of interesting research questions such as can we implement a better data collection for system call tracing? What the information that we want to collect from end-host? Project direction 1: System-call level data collection mechanism comparison study We have several existing data collection mechanisms( Linux Audit , DTrace , Sysdig , osquery , Bluespawn ). While most support Linux, we have a few works for Windows and OSX. Students can implement the same data collection policies for leveraging the different framework to compare efficiency and capability. For instance, student will need to configure data collection mechanisms to collect the same subset of system calls ( e.g., read(), write(), exec(), fork(), send(), recv()). Then the student will run those against standardized workload ( e.g., benchmark suites) and measure the overhead. Project direction 2: User-level support for process-DNS query association Traditional syscall-level monitoring is limited, since system call sequences do not convey much security implication for itself. So we want to explore other events with higher security implications worth collected and analyzed. DNS is one of such indicators, which has been collected by network-level monitoring (e.g., firewall), outside the host. Therefore, we have only been able to associate DNS query to the host, without knowing which process initiated the query. The existing solution gets this implement by installing a kernel module to define the association between the process to mbuf, which later be transferred to the user-level agent. The approach turns out to be too intrusive affecting the system stability. The user also needs to re-install kernel modules for every system update. The project will implement the process-DNS association much lighter fashion by associating two information sources available at user-level. The one is network system call (i.e., send(), recv()) trace and the other is PCAP data. Project direction 3: Collect system data for high-level security analytic You can install data collection agent to your system to collect and store the interesting system events 24x7 and to model system and application behaviors. Binary Similarity Analysis to Detect Supply Chain Attack Supply-chain attack i is a new breed of attack that incurs severe damage to software development and deployment model. From the user perspective, without source code in hand can we measure the difference and specify the changes made to the software. In this project, students can come up with an analysis approach that compares binaries (or bytecodes). The analysis may leverage different representations such Control-Flow Graph (CFG), Function call graph to calculate the delta. The analysis can provide useful primitives detecting and mitigating suspicious changes as follows. Attacker contributing to a well-trusted open-source project. The software vendor implanting a backdoor pretending it to be a mere functionality extension. Programmer mistakes that expose security hole. Project steps Literature survey for Supply Chain Attacks Choose your own update frameworks (Golang, NPM, PIP \u2026) Implement your own example updates Choose a not-to-big, but interesting open source project. Build the source to produce a binary. Extract program representation against the binary. Inject an attack vector (e.g., simple backdoor) Build the source to produce a binary. Extract program representation against the binary. Compare two representations to confirm your approach. If it works, apply your approach to real softwares You can test your approach with .... Reference paper Towards Automatic Software Lineage Inference : Usenix Security 2013 Edge-ML device project Google and Nvidia recently announced their new products to offload machine learning tasks to edge-based IoT computing devices. These devices are equipped with special computation units to accelerate machine learning workloads. While this creates new usage cases, edge-ML also bring new opportunities and threats at once. Edge-ML provides new ways of implementing security solutions or exposes new attack surface for the adversaries to take over. Nvidia Jetson nano board Google Edge TPU processing board If you choose this project, you will provide you edge-ML devices. Project direction 1: Build your own security application using Edge-ML device With new device and its new capability, students can be wild and creative to propose a new security application. For instance, why don\u2019t write an security application that monitors your backyard? Note that edge-ML devices are specialized for image and data processing tasks. Project direction 2: Protecting important information from Edge-ML device With new computation model that edge-ML device introduces, important intellectual assets such as prediction model will be offloaded and transferred to each edge devices. As it is to be deployed outside data center, edge-ML is exposed to the physical attack. For the project, students can think of ways to prevent such assets from being taken over by the adversary. Students needs to consider both runtime and offline aspects. You may consider to utilize Trustzone a security feature supported by ARM processor. Improvement for Automated Large-scale Malware Analysis Study Recently, we observe millions of allegedly payloads are found and reported daily, and this phenomenon pushes the task of manual investigation and analysis nearly infeasible. Industry and academia together have proposed and worked on an automated framework to scale process and analyze malware payloads by implemented automated security sandbox for security and malware analysis. Such a proposal has improved the status, we as a community yet to see many pitfalls and limitation in replaying malware and capture the essence of malicious behavior. From this project, students will perform the following tasks.. Project direction 1: Bridging Threat Intelligence Leveraging Cuckoo environment, we run malware samples to check the consistency between its file, and network threat intelligence (IOCs). How credibility/trust propagate across different domains? We can perform this task as an extension sandbox project. Project steps First implement one of the most well-known open-source sandbox for malware analysis . Write behavioral signature by extending a Cuckoo community API to better judge whether a given payload is indeed malicious thus require further investigation. For a given malware payload, extend the sandbox framework by implementing functionalities to spot anti-debugging techniques and find a way to go around it. References Cuckoo Sandbox Cuckoo Community Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts Implementation of Advanced Persistent Threat (APT) framework for Security Evaluation More research and industry together focuses on Advanced Persistent Threat (APT) designed and launched by nation-level threat actors. Different approaches to monitor, analyze, and mitigate such attacks are proposed. However, research and industry together lacks in framework level support for testing and confirm their effectiveness in protecting valuable assets against such attempts. In this project, students will First, perform a literature research APT attacks. Build a mini-lab environment that would emulate a real-world enterprise environment. Implement and document a number of APT cases. Resources APT Notes - Github project: new repo , old repo APT3 scenario by MITRE Comparison of process-level instrumentation approaches virtualization As our course proceeds, we will learn many different choices in instrumenting software program using different hypervisors to introspect process and system internals at runtime. One can leverage such frameworks to monitor, analyze, and mitigate process and system activities. Instrumentation frameworks Binary re-writing: DynInst Process-level: PIN , Valgrind , DynamoRIO System-level: QEmu While we have different options and frameworks in implementing such measures, design options and its trade-offs are not fully explored by the literatures. For this project, students will First, study and understand different instrumentation frameworks Implement security/program analysis using the framework E.g., Control Flow Graph generator Define a standard workload to run and measure overhead, and usability. Automated IOC processing to produce actionable security rules Indicator of Compromise (IOC) refers to an artifact observed on a network or in an operating system that, with high confidence, indicates a computer intrusion. While IOC transforms the game security by cultivating the smooth exchange of security indicators. To further facilitates security information exchange by addressing the complexity and hectic nature of such security information that we have observed with the existing protocol, a number of different standards are proposed and work on progress ( STIX ). While these proposals attempt to address large portion of problem domain, still we have non-negligible rooms remain for improvements, for instance, many of important security IOCs are posted in a hard to parse not confirming to Internet standard. For instance, many security analysis are written in a plain English in a form of technical report, white-paper, or blog postings. Goal and Problem Statement Threat intelligence is knowledge that allows you to prevent or mitigate cyber-attacks. In this project, We want to survey threat intelligence and verify its correctness and soundness. From valid threat intelligences, We want to find actionable threat intelligence. We want to build a platform or system that can automatically generates the behavioral rule for detection. Link for Actionable Threat Intelligence We have too much sources for threat intelligence whose validity and effectivenesses are not well verified. Some of threat intelligence are well-formed information circulated using community standard (STIX), while the others are just written in paragraphs of plain text, for instance, simple description of attack vectors, blog posts and so forth. IOC (Indicator of Compromise) is one form of threat intelligence, mostly referred as static indicators \u2013 IP addresses, file hashes which are indicators easier for the attackers to forge and evade. we want to extract more dynamic robust indicators which can represent in a form of behavioral action sequence - e.g., process creation tree. Present them using structured notations. can we automate the process? From this project, student will attempts to parse malformed security indicators into STIX or TAXI compatible formation, so as it can be properly translated into standard IOC format and further circulated. Resources Introduction to STIX OpenCTI Conntrack Visualizer What is Conntrack? All of your connections are accessible from your kernel (even ones that you don\u2019t know of!). Can you make a service to visualize for all of Conntrack entries? Resources conntrack-tools Steganography or image forensics \u2013 Analysis and defense for malicious payload embedded documentation Steganography has been a useful technique for the hacker community in embedding different types of malicious payloads into a seemingly benign document to evade security detection measures. This provides attacker an easy way to propagate their malicious payloads yet remain undetected by any security measure. When you see any databases or public resources for malware collections, you realize malware-embedded documents now take the majority. Analyzing Malicious Documents Cheat Sheet https://www.youtube.com/watch?v=np0mPy-EHII Steganography: A Safe Haven for Malware https://books.google.com/books?hl=en&lr=&id=qMB9AiFUWF0C&oi=fnd&pg=PP1&ots=glBaUv19cd&sig=VrUI34kRvs67Lf7r7EMHNRbBtz0 \u2018Dresden Image Database\u2019 for benchmarking digital image forensics Page last revised on: 2019-09-20","title":"Projects"},{"location":"projects/#system-call-level-data-collection-for-behavioral-security-analysis","text":"","title":"System call level data collection for behavioral security analysis"},{"location":"projects/#motivation","text":"In modern security scene, many security solutions are based on data collected from each end-host (vs. out-host or perimeter network monitoring). Therefore, it is essential to have an efficient and robust data collection agent at each end-host. Many existing in-host monitoring solutions choose to collect a subset of system calls and their argument for security analysis. Efficient and reliable data collection at end-host is high demand, and provide essential building block data-driven security research. Therefore, it brings in a number of interesting research questions such as can we implement a better data collection for system call tracing? What the information that we want to collect from end-host?","title":"Motivation"},{"location":"projects/#project-direction-1-system-call-level-data-collection-mechanism-comparison-study","text":"We have several existing data collection mechanisms( Linux Audit , DTrace , Sysdig , osquery , Bluespawn ). While most support Linux, we have a few works for Windows and OSX. Students can implement the same data collection policies for leveraging the different framework to compare efficiency and capability. For instance, student will need to configure data collection mechanisms to collect the same subset of system calls ( e.g., read(), write(), exec(), fork(), send(), recv()). Then the student will run those against standardized workload ( e.g., benchmark suites) and measure the overhead.","title":"Project direction 1: System-call level data collection mechanism comparison study"},{"location":"projects/#project-direction-2-user-level-support-for-process-dns-query-association","text":"Traditional syscall-level monitoring is limited, since system call sequences do not convey much security implication for itself. So we want to explore other events with higher security implications worth collected and analyzed. DNS is one of such indicators, which has been collected by network-level monitoring (e.g., firewall), outside the host. Therefore, we have only been able to associate DNS query to the host, without knowing which process initiated the query. The existing solution gets this implement by installing a kernel module to define the association between the process to mbuf, which later be transferred to the user-level agent. The approach turns out to be too intrusive affecting the system stability. The user also needs to re-install kernel modules for every system update. The project will implement the process-DNS association much lighter fashion by associating two information sources available at user-level. The one is network system call (i.e., send(), recv()) trace and the other is PCAP data.","title":"Project direction 2: User-level support for process-DNS query association"},{"location":"projects/#project-direction-3-collect-system-data-for-high-level-security-analytic","text":"You can install data collection agent to your system to collect and store the interesting system events 24x7 and to model system and application behaviors.","title":"Project direction 3: Collect system data for high-level security analytic"},{"location":"projects/#binary-similarity-analysis-to-detect-supply-chain-attack","text":"Supply-chain attack i is a new breed of attack that incurs severe damage to software development and deployment model. From the user perspective, without source code in hand can we measure the difference and specify the changes made to the software. In this project, students can come up with an analysis approach that compares binaries (or bytecodes). The analysis may leverage different representations such Control-Flow Graph (CFG), Function call graph to calculate the delta. The analysis can provide useful primitives detecting and mitigating suspicious changes as follows. Attacker contributing to a well-trusted open-source project. The software vendor implanting a backdoor pretending it to be a mere functionality extension. Programmer mistakes that expose security hole.","title":"Binary Similarity Analysis to Detect Supply Chain Attack"},{"location":"projects/#project-steps","text":"Literature survey for Supply Chain Attacks Choose your own update frameworks (Golang, NPM, PIP \u2026) Implement your own example updates Choose a not-to-big, but interesting open source project. Build the source to produce a binary. Extract program representation against the binary. Inject an attack vector (e.g., simple backdoor) Build the source to produce a binary. Extract program representation against the binary. Compare two representations to confirm your approach. If it works, apply your approach to real softwares You can test your approach with ....","title":"Project steps"},{"location":"projects/#reference-paper","text":"Towards Automatic Software Lineage Inference : Usenix Security 2013","title":"Reference paper"},{"location":"projects/#edge-ml-device-project","text":"Google and Nvidia recently announced their new products to offload machine learning tasks to edge-based IoT computing devices. These devices are equipped with special computation units to accelerate machine learning workloads. While this creates new usage cases, edge-ML also bring new opportunities and threats at once. Edge-ML provides new ways of implementing security solutions or exposes new attack surface for the adversaries to take over. Nvidia Jetson nano board Google Edge TPU processing board If you choose this project, you will provide you edge-ML devices.","title":"Edge-ML device project"},{"location":"projects/#project-direction-1-build-your-own-security-application-using-edge-ml-device","text":"With new device and its new capability, students can be wild and creative to propose a new security application. For instance, why don\u2019t write an security application that monitors your backyard? Note that edge-ML devices are specialized for image and data processing tasks.","title":"Project direction 1: Build your own security application using Edge-ML device"},{"location":"projects/#project-direction-2-protecting-important-information-from-edge-ml-device","text":"With new computation model that edge-ML device introduces, important intellectual assets such as prediction model will be offloaded and transferred to each edge devices. As it is to be deployed outside data center, edge-ML is exposed to the physical attack. For the project, students can think of ways to prevent such assets from being taken over by the adversary. Students needs to consider both runtime and offline aspects. You may consider to utilize Trustzone a security feature supported by ARM processor.","title":"Project direction 2: Protecting important information from Edge-ML device"},{"location":"projects/#improvement-for-automated-large-scale-malware-analysis-study","text":"Recently, we observe millions of allegedly payloads are found and reported daily, and this phenomenon pushes the task of manual investigation and analysis nearly infeasible. Industry and academia together have proposed and worked on an automated framework to scale process and analyze malware payloads by implemented automated security sandbox for security and malware analysis. Such a proposal has improved the status, we as a community yet to see many pitfalls and limitation in replaying malware and capture the essence of malicious behavior. From this project, students will perform the following tasks..","title":"Improvement for Automated Large-scale Malware Analysis Study"},{"location":"projects/#project-direction-1-bridging-threat-intelligence","text":"Leveraging Cuckoo environment, we run malware samples to check the consistency between its file, and network threat intelligence (IOCs). How credibility/trust propagate across different domains? We can perform this task as an extension sandbox project.","title":"Project direction 1: Bridging Threat Intelligence"},{"location":"projects/#project-steps_1","text":"First implement one of the most well-known open-source sandbox for malware analysis . Write behavioral signature by extending a Cuckoo community API to better judge whether a given payload is indeed malicious thus require further investigation. For a given malware payload, extend the sandbox framework by implementing functionalities to spot anti-debugging techniques and find a way to go around it.","title":"Project steps"},{"location":"projects/#references","text":"Cuckoo Sandbox Cuckoo Community Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts","title":"References"},{"location":"projects/#implementation-of-advanced-persistent-threat-apt-framework-for-security-evaluation","text":"More research and industry together focuses on Advanced Persistent Threat (APT) designed and launched by nation-level threat actors. Different approaches to monitor, analyze, and mitigate such attacks are proposed. However, research and industry together lacks in framework level support for testing and confirm their effectiveness in protecting valuable assets against such attempts. In this project, students will First, perform a literature research APT attacks. Build a mini-lab environment that would emulate a real-world enterprise environment. Implement and document a number of APT cases.","title":"Implementation of Advanced Persistent Threat (APT) framework for Security Evaluation"},{"location":"projects/#resources","text":"APT Notes - Github project: new repo , old repo APT3 scenario by MITRE","title":"Resources"},{"location":"projects/#comparison-of-process-level-instrumentation-approaches-virtualization","text":"As our course proceeds, we will learn many different choices in instrumenting software program using different hypervisors to introspect process and system internals at runtime. One can leverage such frameworks to monitor, analyze, and mitigate process and system activities. Instrumentation frameworks Binary re-writing: DynInst Process-level: PIN , Valgrind , DynamoRIO System-level: QEmu While we have different options and frameworks in implementing such measures, design options and its trade-offs are not fully explored by the literatures. For this project, students will First, study and understand different instrumentation frameworks Implement security/program analysis using the framework E.g., Control Flow Graph generator Define a standard workload to run and measure overhead, and usability.","title":"Comparison of process-level instrumentation approaches virtualization"},{"location":"projects/#automated-ioc-processing-to-produce-actionable-security-rules","text":"Indicator of Compromise (IOC) refers to an artifact observed on a network or in an operating system that, with high confidence, indicates a computer intrusion. While IOC transforms the game security by cultivating the smooth exchange of security indicators. To further facilitates security information exchange by addressing the complexity and hectic nature of such security information that we have observed with the existing protocol, a number of different standards are proposed and work on progress ( STIX ). While these proposals attempt to address large portion of problem domain, still we have non-negligible rooms remain for improvements, for instance, many of important security IOCs are posted in a hard to parse not confirming to Internet standard. For instance, many security analysis are written in a plain English in a form of technical report, white-paper, or blog postings.","title":"Automated IOC processing to produce actionable security rules"},{"location":"projects/#goal-and-problem-statement","text":"Threat intelligence is knowledge that allows you to prevent or mitigate cyber-attacks. In this project, We want to survey threat intelligence and verify its correctness and soundness. From valid threat intelligences, We want to find actionable threat intelligence. We want to build a platform or system that can automatically generates the behavioral rule for detection. Link for Actionable Threat Intelligence We have too much sources for threat intelligence whose validity and effectivenesses are not well verified. Some of threat intelligence are well-formed information circulated using community standard (STIX), while the others are just written in paragraphs of plain text, for instance, simple description of attack vectors, blog posts and so forth. IOC (Indicator of Compromise) is one form of threat intelligence, mostly referred as static indicators \u2013 IP addresses, file hashes which are indicators easier for the attackers to forge and evade. we want to extract more dynamic robust indicators which can represent in a form of behavioral action sequence - e.g., process creation tree. Present them using structured notations. can we automate the process? From this project, student will attempts to parse malformed security indicators into STIX or TAXI compatible formation, so as it can be properly translated into standard IOC format and further circulated.","title":"Goal and Problem Statement"},{"location":"projects/#resources_1","text":"Introduction to STIX OpenCTI","title":"Resources"},{"location":"projects/#conntrack-visualizer","text":"What is Conntrack? All of your connections are accessible from your kernel (even ones that you don\u2019t know of!). Can you make a service to visualize for all of Conntrack entries?","title":"Conntrack Visualizer"},{"location":"projects/#resources_2","text":"conntrack-tools","title":"Resources"},{"location":"projects/#steganography-or-image-forensics-analysis-and-defense-for-malicious-payload-embedded-documentation","text":"Steganography has been a useful technique for the hacker community in embedding different types of malicious payloads into a seemingly benign document to evade security detection measures. This provides attacker an easy way to propagate their malicious payloads yet remain undetected by any security measure. When you see any databases or public resources for malware collections, you realize malware-embedded documents now take the majority. Analyzing Malicious Documents Cheat Sheet https://www.youtube.com/watch?v=np0mPy-EHII Steganography: A Safe Haven for Malware https://books.google.com/books?hl=en&lr=&id=qMB9AiFUWF0C&oi=fnd&pg=PP1&ots=glBaUv19cd&sig=VrUI34kRvs67Lf7r7EMHNRbBtz0 \u2018Dresden Image Database\u2019 for benchmarking digital image forensics Page last revised on: 2019-09-20","title":"Steganography or image forensics -- Analysis and defense for malicious payload embedded documentation"},{"location":"projects1/","text":"System call level data collection for behavioral security analysis Motivation In modern security scene, many security solutions are based on data collected from each end-host (vs. out-host or perimeter network monitoring). Therefore, it is essential to have an efficient and robust data collection agent at each end-host. Many existing in-host monitoring solutions choose to collect a subset of system calls and their argument for security analysis. Efficient and reliable data collection at end-host is high demand, and provide essential building block data-driven security research. Therefore, it brings in a number of interesting research questions such as can we implement a better data collection for system call tracing? What the information that we want to collect from end-host? Project direction 1: System-call level data collection mechanism comparison study We have several existing data collection mechanisms( Linux Audit , DTrace , Sysdig , osquery , Bluespawn ). While most support Linux, we have a few works for Windows and OSX. Students can implement the same data collection policies for leveraging the different framework to compare efficiency and capability. For instance, student will need to configure data collection mechanisms to collect the same subset of system calls ( e.g., read(), write(), exec(), fork(), send(), recv()). Then the student will run those against standardized workload ( e.g., benchmark suites) and measure the overhead. Project direction 2: User-level support for process-DNS query association Traditional syscall-level monitoring is limited, since system call sequences do not convey much security implication for itself. So we want to explore other events with higher security implications worth collected and analyzed. DNS is one of such indicators, which has been collected by network-level monitoring (e.g., firewall), outside the host. Therefore, we have only been able to associate DNS query to the host, without knowing which process initiated the query. The existing solution gets this implement by installing a kernel module to define the association between the process to mbuf, which later be transferred to the user-level agent. The approach turns out to be too intrusive affecting the system stability. The user also needs to re-install kernel modules for every system update. The project will implement the process-DNS association much lighter fashion by associating two information sources available at user-level. The one is network system call (i.e., send(), recv()) trace and the other is PCAP data. Project direction 3: Collect system data for high-level security analytic You can install data collection agent to your system to collect and store the interesting system events 24x7 and to model system and application behaviors. Binary Similarity Analysis to Detect Supply Chain Attack Supply-chain attack i is a new breed of attack that incurs severe damage to software development and deployment model. From the user perspective, without source code in hand can we measure the difference and specify the changes made to the software. In this project, students can come up with an analysis approach that compares binaries (or bytecodes). The analysis may leverage different representations such Control-Flow Graph (CFG), Function call graph to calculate the delta. The analysis can provide useful primitives detecting and mitigating suspicious changes as follows. Attacker contributing to a well-trusted open-source project. The software vendor implanting a backdoor pretending it to be a mere functionality extension. Programmer mistakes that expose security hole. Project steps Literature survey for Supply Chain Attacks Choose your own update frameworks (Golang, NPM, PIP \u2026) Implement your own example updates Choose a not-to-big, but interesting open source project. Build the source to produce a binary. Extract program representation against the binary. Inject an attack vector (e.g., simple backdoor) Build the source to produce a binary. Extract program representation against the binary. Compare two representations to confirm your approach. If it works, apply your approach to real softwares You can test your approach with .... Resources Towards Automatic Software Lineage Inference : Usenix Security 2013 Improvement for Automated Large-scale Malware Analysis Study Recently, we observe millions of allegedly payloads are found and reported daily, and this phenomenon pushes the task of manual investigation and analysis nearly infeasible. Industry and academia together have proposed and worked on an automated framework to scale process and analyze malware payloads by implemented automated security sandbox for security and malware analysis. Such a proposal has improved the status, we as a community yet to see many pitfalls and limitation in replaying malware and capture the essence of malicious behavior. From this project, students will perform the following tasks.. Project direction 1: Bridging Threat Intelligence Leveraging Cuckoo environment, we run malware samples to check the consistency between its file, and network threat intelligence (IOCs). How credibility/trust propagate across different domains? We can perform this task as an extension sandbox project. Project steps First implement one of the most well-known open-source sandbox for malware analysis . Write behavioral signature by extending a Cuckoo community API to better judge whether a given payload is indeed malicious thus require further investigation. For a given malware payload, extend the sandbox framework by implementing functionalities to spot anti-debugging techniques and find a way to go around it. References Cuckoo Sandbox Cuckoo Community Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts Implementation of Advanced Persistent Threat (APT) framework for Security Evaluation More research and industry together focuses on Advanced Persistent Threat (APT) designed and launched by nation-level threat actors. Different approaches to monitor, analyze, and mitigate such attacks are proposed. However, research and industry together lacks in framework level support for testing and confirm their effectiveness in protecting valuable assets against such attempts. In this project, students will First, perform a literature research APT attacks. Build a mini-lab environment that would emulate a real-world enterprise environment. Implement and document a number of APT cases. Resources APT Notes - Github project: new repo , old repo APT3 scenario by MITRE Comparison of process-level instrumentation approaches virtualization As our course proceeds, we will learn many different choices in instrumenting software program using different hypervisors to introspect process and system internals at runtime. One can leverage such frameworks to monitor, analyze, and mitigate process and system activities. Instrumentation frameworks Binary re-writing: DynInst Process-level: PIN , Valgrind , DynamoRIO System-level: QEmu While we have different options and frameworks in implementing such measures, design options and its trade-offs are not fully explored by the literatures. For this project, students will First, study and understand different instrumentation frameworks Implement security/program analysis using the framework E.g., Control Flow Graph generator Define a standard workload to run and measure overhead, and usability. Edge-ML device project Google and Nvidia recently announced their new products to offload machine learning tasks to edge-based IoT computing devicators. To further facilitates security information exchange by addressing the complexity and hectic nature of such security information that we have observed with the existing protocol, a number of different standards are proposed and work on progress ( STIX ). While these proposals attempt to address large portion of problem domain, still we have non-negligible rooms remain for improvements, for instance, many of important security IOCs are posted in a hard to parse not confirming to Internet standard. For instance, many security analysis are written in a plain English in a form of technical report, white-paper, or blog postings. Goal and Problem Statement Threat intelligence is knowledge that allows you to prevent or mitigate cyber-attacks. In this project, We want to survey threat intelligence and verify its correctness and soundness. From valid threat intelligences, We want to find actionable threat intelligence. We want to build a platform or system that can automatically generates the behavioral rule for detection. Link for Actionable Threat Intelligence We have too much sources for threat intelligence whose validity and effectivenesses are not well verified. Some of threat intelligence are well-formed information circulated using community standard (STIX), while the others are just written in paragraphs of plain text, for instance, simple description of attack vectors, blog posts and so forth. IOC (Indicator of Compromise) is one form of threat intelligence, mostly referred as static indicators \u2013 IP addresses, file hashes which are indicators easier for the attackers to forge and evade. we want to extract more dynamic robust indicators which can represent in a form of behavioral action sequence - e.g., process creation tree. Present them using structured notations. can we automate the process? From this project, student will attempts to parse malformed security indicators into STIX or TAXI compatible formation, so as it can be properly translated into standard IOC format and further circulated. Resources Introduction to STIX OpenCTI Conntrack Visualizer What is Conntrack? All of your connections are accessible from your kernel (even ones that you don\u2019t know of!). Can you make a service to visualize for all of Conntrack entries? Resources conntrack-tools Steganography or image forensics \u2013 Analysis and defense for malicious payload embedded documentation Steganography has been a useful technique for the hacker community in embedding different types of malicious payloads into a seemingly benign document to evade security detection measures. This provides attacker an easy way to propagate their malicious payloads yet remain undetected by any security measure. When you see any databases or public resources for malware collections, you realize malware-embedded documents now take the majority. Analyzing Malicious Documents Cheat Sheet Youtube clip Steganography: A Safe Haven for Malware Book on Steganography \u2018Dresden Image Database\u2019 for benchmarking digital image forensics Page last revised on: 2019-09-20","title":"Projects1"},{"location":"projects1/#system-call-level-data-collection-for-behavioral-security-analysis","text":"","title":"System call level data collection for behavioral security analysis"},{"location":"projects1/#motivation","text":"In modern security scene, many security solutions are based on data collected from each end-host (vs. out-host or perimeter network monitoring). Therefore, it is essential to have an efficient and robust data collection agent at each end-host. Many existing in-host monitoring solutions choose to collect a subset of system calls and their argument for security analysis. Efficient and reliable data collection at end-host is high demand, and provide essential building block data-driven security research. Therefore, it brings in a number of interesting research questions such as can we implement a better data collection for system call tracing? What the information that we want to collect from end-host?","title":"Motivation"},{"location":"projects1/#project-direction-1-system-call-level-data-collection-mechanism-comparison-study","text":"We have several existing data collection mechanisms( Linux Audit , DTrace , Sysdig , osquery , Bluespawn ). While most support Linux, we have a few works for Windows and OSX. Students can implement the same data collection policies for leveraging the different framework to compare efficiency and capability. For instance, student will need to configure data collection mechanisms to collect the same subset of system calls ( e.g., read(), write(), exec(), fork(), send(), recv()). Then the student will run those against standardized workload ( e.g., benchmark suites) and measure the overhead.","title":"Project direction 1: System-call level data collection mechanism comparison study"},{"location":"projects1/#project-direction-2-user-level-support-for-process-dns-query-association","text":"Traditional syscall-level monitoring is limited, since system call sequences do not convey much security implication for itself. So we want to explore other events with higher security implications worth collected and analyzed. DNS is one of such indicators, which has been collected by network-level monitoring (e.g., firewall), outside the host. Therefore, we have only been able to associate DNS query to the host, without knowing which process initiated the query. The existing solution gets this implement by installing a kernel module to define the association between the process to mbuf, which later be transferred to the user-level agent. The approach turns out to be too intrusive affecting the system stability. The user also needs to re-install kernel modules for every system update. The project will implement the process-DNS association much lighter fashion by associating two information sources available at user-level. The one is network system call (i.e., send(), recv()) trace and the other is PCAP data.","title":"Project direction 2: User-level support for process-DNS query association"},{"location":"projects1/#project-direction-3-collect-system-data-for-high-level-security-analytic","text":"You can install data collection agent to your system to collect and store the interesting system events 24x7 and to model system and application behaviors.","title":"Project direction 3: Collect system data for high-level security analytic"},{"location":"projects1/#binary-similarity-analysis-to-detect-supply-chain-attack","text":"Supply-chain attack i is a new breed of attack that incurs severe damage to software development and deployment model. From the user perspective, without source code in hand can we measure the difference and specify the changes made to the software. In this project, students can come up with an analysis approach that compares binaries (or bytecodes). The analysis may leverage different representations such Control-Flow Graph (CFG), Function call graph to calculate the delta. The analysis can provide useful primitives detecting and mitigating suspicious changes as follows. Attacker contributing to a well-trusted open-source project. The software vendor implanting a backdoor pretending it to be a mere functionality extension. Programmer mistakes that expose security hole.","title":"Binary Similarity Analysis to Detect Supply Chain Attack"},{"location":"projects1/#project-steps","text":"Literature survey for Supply Chain Attacks Choose your own update frameworks (Golang, NPM, PIP \u2026) Implement your own example updates Choose a not-to-big, but interesting open source project. Build the source to produce a binary. Extract program representation against the binary. Inject an attack vector (e.g., simple backdoor) Build the source to produce a binary. Extract program representation against the binary. Compare two representations to confirm your approach. If it works, apply your approach to real softwares You can test your approach with ....","title":"Project steps"},{"location":"projects1/#resources","text":"Towards Automatic Software Lineage Inference : Usenix Security 2013","title":"Resources"},{"location":"projects1/#improvement-for-automated-large-scale-malware-analysis-study","text":"Recently, we observe millions of allegedly payloads are found and reported daily, and this phenomenon pushes the task of manual investigation and analysis nearly infeasible. Industry and academia together have proposed and worked on an automated framework to scale process and analyze malware payloads by implemented automated security sandbox for security and malware analysis. Such a proposal has improved the status, we as a community yet to see many pitfalls and limitation in replaying malware and capture the essence of malicious behavior. From this project, students will perform the following tasks..","title":"Improvement for Automated Large-scale Malware Analysis Study"},{"location":"projects1/#project-direction-1-bridging-threat-intelligence","text":"Leveraging Cuckoo environment, we run malware samples to check the consistency between its file, and network threat intelligence (IOCs). How credibility/trust propagate across different domains? We can perform this task as an extension sandbox project.","title":"Project direction 1: Bridging Threat Intelligence"},{"location":"projects1/#project-steps_1","text":"First implement one of the most well-known open-source sandbox for malware analysis . Write behavioral signature by extending a Cuckoo community API to better judge whether a given payload is indeed malicious thus require further investigation. For a given malware payload, extend the sandbox framework by implementing functionalities to spot anti-debugging techniques and find a way to go around it.","title":"Project steps"},{"location":"projects1/#references","text":"Cuckoo Sandbox Cuckoo Community Spotless Sandboxes: Evading Malware Analysis Systems using Wear-and-Tear Artifacts","title":"References"},{"location":"projects1/#implementation-of-advanced-persistent-threat-apt-framework-for-security-evaluation","text":"More research and industry together focuses on Advanced Persistent Threat (APT) designed and launched by nation-level threat actors. Different approaches to monitor, analyze, and mitigate such attacks are proposed. However, research and industry together lacks in framework level support for testing and confirm their effectiveness in protecting valuable assets against such attempts. In this project, students will First, perform a literature research APT attacks. Build a mini-lab environment that would emulate a real-world enterprise environment. Implement and document a number of APT cases.","title":"Implementation of Advanced Persistent Threat (APT) framework for Security Evaluation"},{"location":"projects1/#resources_1","text":"APT Notes - Github project: new repo , old repo APT3 scenario by MITRE","title":"Resources"},{"location":"projects1/#comparison-of-process-level-instrumentation-approaches-virtualization","text":"As our course proceeds, we will learn many different choices in instrumenting software program using different hypervisors to introspect process and system internals at runtime. One can leverage such frameworks to monitor, analyze, and mitigate process and system activities. Instrumentation frameworks Binary re-writing: DynInst Process-level: PIN , Valgrind , DynamoRIO System-level: QEmu While we have different options and frameworks in implementing such measures, design options and its trade-offs are not fully explored by the literatures. For this project, students will First, study and understand different instrumentation frameworks Implement security/program analysis using the framework E.g., Control Flow Graph generator Define a standard workload to run and measure overhead, and usability.","title":"Comparison of process-level instrumentation approaches virtualization"},{"location":"projects1/#edge-ml-device-project","text":"Google and Nvidia recently announced their new products to offload machine learning tasks to edge-based IoT computing devicators. To further facilitates security information exchange by addressing the complexity and hectic nature of such security information that we have observed with the existing protocol, a number of different standards are proposed and work on progress ( STIX ). While these proposals attempt to address large portion of problem domain, still we have non-negligible rooms remain for improvements, for instance, many of important security IOCs are posted in a hard to parse not confirming to Internet standard. For instance, many security analysis are written in a plain English in a form of technical report, white-paper, or blog postings.","title":"Edge-ML device project"},{"location":"projects1/#goal-and-problem-statement","text":"Threat intelligence is knowledge that allows you to prevent or mitigate cyber-attacks. In this project, We want to survey threat intelligence and verify its correctness and soundness. From valid threat intelligences, We want to find actionable threat intelligence. We want to build a platform or system that can automatically generates the behavioral rule for detection. Link for Actionable Threat Intelligence We have too much sources for threat intelligence whose validity and effectivenesses are not well verified. Some of threat intelligence are well-formed information circulated using community standard (STIX), while the others are just written in paragraphs of plain text, for instance, simple description of attack vectors, blog posts and so forth. IOC (Indicator of Compromise) is one form of threat intelligence, mostly referred as static indicators \u2013 IP addresses, file hashes which are indicators easier for the attackers to forge and evade. we want to extract more dynamic robust indicators which can represent in a form of behavioral action sequence - e.g., process creation tree. Present them using structured notations. can we automate the process? From this project, student will attempts to parse malformed security indicators into STIX or TAXI compatible formation, so as it can be properly translated into standard IOC format and further circulated.","title":"Goal and Problem Statement"},{"location":"projects1/#resources_2","text":"Introduction to STIX OpenCTI","title":"Resources"},{"location":"projects1/#conntrack-visualizer","text":"What is Conntrack? All of your connections are accessible from your kernel (even ones that you don\u2019t know of!). Can you make a service to visualize for all of Conntrack entries?","title":"Conntrack Visualizer"},{"location":"projects1/#resources_3","text":"conntrack-tools","title":"Resources"},{"location":"projects1/#steganography-or-image-forensics-analysis-and-defense-for-malicious-payload-embedded-documentation","text":"Steganography has been a useful technique for the hacker community in embedding different types of malicious payloads into a seemingly benign document to evade security detection measures. This provides attacker an easy way to propagate their malicious payloads yet remain undetected by any security measure. When you see any databases or public resources for malware collections, you realize malware-embedded documents now take the majority. Analyzing Malicious Documents Cheat Sheet Youtube clip Steganography: A Safe Haven for Malware Book on Steganography \u2018Dresden Image Database\u2019 for benchmarking digital image forensics Page last revised on: 2019-09-20","title":"Steganography or image forensics -- Analysis and defense for malicious payload embedded documentation"},{"location":"quiz01/","text":"Quiz 1 (10pt) - Disassembling binary and patching From this exercise, we aim to run the basics of binary reverse engineering to find a secret from binary, modify its value, and change the execution. Exercise description [Step 0] Set-up your environment (Ubuntu VM) Download VirtualBox install it to your computer. Create a Ubuntu 16.04 (64-bit) VM instance After initial boot, enable 64-bit Ubuntu to run 32-bit executables by running, sudo apt update sudo apt install libc6-i386 Install necessary tools gdb-peda , radare2 \u2026 Download binaries from the folliwng links crackme0x00 , crackme0x01 , crackme0x02 [Part 1 - 3pt] Find the secret Reverse engineering three payloads with Radare 2 (or with your favorite tools) to find a secret. Write a secret value to README.md and simple description of how did you find secrets. [Part 2 - 3pt] Modify binary to change the secret For crackme0x00 and crackme0x01 payloads, you will modify binaries to change the secret values. The new secret value will be specific to your net_id . The following will give you new secret value. $ export m=$(echo \"<your_net_id>\" |md5sum |cut -d ' ' -f 1|tr '[:lower:]' '[:upper:]') ;echo \"obase=10; ibase=16; ${m: -4}\"|bc Modified binaries will be named as below. crackme0x00_<your_net_id> crackme0x01_<your_net_id> [Part 3 - 4pt] Modify binary to change execution For crackme0x01 and crackme0x02 payloads, overwrite an instruction so as to print success message regardless of its inputs. Modified binary will be named as below. crackme0x01_jmp crackme0x02_jmp [Extra] other tools? IDA Pro (free version), Ghidra (open-sourced by NSA) Tools for the same purpose, with better GUI interface. Share your experience! (15 ~ 20 min) This can replace paper presentation. Submission Tar/gzip your outputs using the following command and upload it to eLearning. For each part, please add simple description regarding how did you get the result. tar cvzf cs6332q01.tgz README.md crackme0x0?_*","title":"quiz 0x01"},{"location":"quiz01/#quiz-1-10pt-disassembling-binary-and-patching","text":"From this exercise, we aim to run the basics of binary reverse engineering to find a secret from binary, modify its value, and change the execution.","title":"Quiz 1 (10pt) - Disassembling binary and patching"},{"location":"quiz01/#exercise-description","text":"","title":"Exercise description"},{"location":"quiz01/#step-0-set-up-your-environment-ubuntu-vm","text":"Download VirtualBox install it to your computer. Create a Ubuntu 16.04 (64-bit) VM instance After initial boot, enable 64-bit Ubuntu to run 32-bit executables by running, sudo apt update sudo apt install libc6-i386 Install necessary tools gdb-peda , radare2 \u2026 Download binaries from the folliwng links crackme0x00 , crackme0x01 , crackme0x02","title":"[Step 0] Set-up your environment (Ubuntu VM)"},{"location":"quiz01/#part-1-3pt-find-the-secret","text":"Reverse engineering three payloads with Radare 2 (or with your favorite tools) to find a secret. Write a secret value to README.md and simple description of how did you find secrets.","title":"[Part 1 - 3pt] Find the secret"},{"location":"quiz01/#part-2-3pt-modify-binary-to-change-the-secret","text":"For crackme0x00 and crackme0x01 payloads, you will modify binaries to change the secret values. The new secret value will be specific to your net_id . The following will give you new secret value. $ export m=$(echo \"<your_net_id>\" |md5sum |cut -d ' ' -f 1|tr '[:lower:]' '[:upper:]') ;echo \"obase=10; ibase=16; ${m: -4}\"|bc Modified binaries will be named as below. crackme0x00_<your_net_id> crackme0x01_<your_net_id>","title":"[Part 2 - 3pt] Modify binary to change the secret"},{"location":"quiz01/#part-3-4pt-modify-binary-to-change-execution","text":"For crackme0x01 and crackme0x02 payloads, overwrite an instruction so as to print success message regardless of its inputs. Modified binary will be named as below. crackme0x01_jmp crackme0x02_jmp","title":"[Part 3 - 4pt] Modify binary to change execution"},{"location":"quiz01/#extra-other-tools","text":"IDA Pro (free version), Ghidra (open-sourced by NSA) Tools for the same purpose, with better GUI interface. Share your experience! (15 ~ 20 min) This can replace paper presentation.","title":"[Extra] other tools?"},{"location":"quiz01/#submission","text":"Tar/gzip your outputs using the following command and upload it to eLearning. For each part, please add simple description regarding how did you get the result. tar cvzf cs6332q01.tgz README.md crackme0x0?_*","title":"Submission"},{"location":"quizzes/","text":"Quizzes Quiz 1 Page last revised on: 2019-09-06","title":"Quizzes"},{"location":"quizzes/#quizzes","text":"Quiz 1 Page last revised on: 2019-09-06","title":"Quizzes"},{"location":"radare2-workthrough/","text":"Tutorial for R2 + crackme0x00 Starting R2 $ tmux a $ wget www.syssec.org/crackmes/crackme0x00 $ r2 crackme0x00 [0x08048360]> aaa :analyze binary [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [x] Analyze function calls (aac) [x] Use -AA or aaaa to perform additional experimental analysis. [x] Constructing a function name for fcn.* and sym.func.* functions (aan) [0x08048493]> afl ; list functions 0x080482f8 1 23 sym._init 0x08048320 1 6 sym.imp.__libc_start_main 0x08048330 1 6 sym.imp.scanf 0x08048340 1 6 sym.imp.printf Investigating binary [0x08048360]> i:(nfo) blksz 0x0 block 0x100 fd 3 file crackme0x00 format elf ... [0x08048414]> i~nx : i|grep nx nx true ... [0x08048414]> ii : imports ... [0x08048414]> is : symtab entries ... [0x08048414]> izzz : dump all strings from the binary ... 000 0x00000028 0x08048028 4 10 (LOAD0) utf16le 4 \\t( 001 0x00000154 0x08048154 18 19 (.interp) ascii /lib/ld-linux.so.2 [0x08048414]> izzz~Password 014 0x00000581 0x08048581 10 11 (.rodata) ascii Password: 016 0x00000596 0x08048596 18 19 (.rodata) ascii Invalid Password!\\n 017 0x000005a9 0x080485a9 15 16 (.rodata) ascii Password OK :)\\n Investigate function [0x08048493]> s main # seek to main symbol [0x08048414]> pdf # disasemble function ... [0x08048414]> pdc ; decompiled code [0x08048414]> v # visual mode - rotate with 'p', hex, disasm, debug, words, buf; exit with 'q' [0x08048414]> VV # visual mode graph; rotate with 'p' for different BB representations; exit with 'q' [0x0804848c]> ps @ str.250382 # string type variable 250382 [0x0804848c]> s str.250382 [0x0804858f]> pds ;-- str.250382: 0x0804858f \"250382\" ;-- str.Invalid_Password: 0x08048596 \"Invalid Password!\\n\" ... Basic Command format Command syntax: [.][times][cmd][~grep][@[@iter]addr!size][|>pipe] * ; Command chaining: x 3;s+3;pi 3;s+3;pxo 4; * | Pipe with shell commands: pd | less * ! Run shell commands: !cat /etc/passwd * !! Escapes to shell, run command and pass output to radare buffer * Note: The double exclamation mark tells radare to skip the plugin list to find an IO plugin handling this command to launch it directly to the shell. A single one will walk through the io plugin list. * ` Radare commands: wx `!ragg2 -i exec` * ~ grep * ~! grep -v * ~[n] grep by columns afl~[0] * ~:n grep by rows afl~:0 pi~mov,eax ; lines with mov or eax pi~mov&eax ; lines with mov and eax pi~mov,eax:6 ; 6 first lines with mov or eax pd 20~call[0]:0 ; grep first column of the first row matching 'call' .cmd Interprets command output is* prints symbols .is* interprets output and define the symbols in radare (normally they are already loaded if r2 was not invoked with -n) .. repeats last commands (same as enter \\n) ( Used to define and run macros $ Used to define alias $$ : Resolves to current address Offsets ( @ ) are absolute, we can use $$ for relative ones @ $$+4 ? Evaluate expression [0x00000000]> ? 33 +2 35 0x23 043 0000:0023 35 00100011 35.0 0.000000 Note: | and & need to be escaped ?$? Help for variables used in expressions $$ : Here $s : File size $b : Block size $l : Opcode length $j : When $$ is at a jmp , $j is the address where we are going to jump to $f : Same for jmp fail address $m : Opcode memory reference (e.g. mov eax,[0x10] => 0x10) ??? Help for ? command ?i Takes input from stdin. Eg ?i username ?? Result from previous operations ?s from to [step] : Generates sequence from to every ?p : Get physical address for given virtual address ?P : Get virtual address for given physical one ?v Show hex value of math expr ?v 0x1625d4ca ^ 0x72ca4247 = 0x64ef968d ?v 0x4141414a - 0x41414140 = 0xa ?l str : Returns the length of string @@ : Used for iterations wx ff @@10 20 30 Writes ff at offsets 10, 20 and 30 wx ff @@`?s 1 10 2` Writes ff at offsets 1, 2 and 3 wx 90 @@ sym.* Writes a nop on every symbol","title":"Tutorial for R2 + crackme0x00"},{"location":"radare2-workthrough/#tutorial-for-r2-crackme0x00","text":"","title":"Tutorial for R2 + crackme0x00"},{"location":"radare2-workthrough/#starting-r2","text":"$ tmux a $ wget www.syssec.org/crackmes/crackme0x00 $ r2 crackme0x00 [0x08048360]> aaa :analyze binary [x] Analyze all flags starting with sym. and entry0 (aa) [x] Analyze len bytes of instructions for references (aar) [x] Analyze function calls (aac) [x] Use -AA or aaaa to perform additional experimental analysis. [x] Constructing a function name for fcn.* and sym.func.* functions (aan) [0x08048493]> afl ; list functions 0x080482f8 1 23 sym._init 0x08048320 1 6 sym.imp.__libc_start_main 0x08048330 1 6 sym.imp.scanf 0x08048340 1 6 sym.imp.printf","title":"Starting R2"},{"location":"radare2-workthrough/#investigating-binary","text":"[0x08048360]> i:(nfo) blksz 0x0 block 0x100 fd 3 file crackme0x00 format elf ... [0x08048414]> i~nx : i|grep nx nx true ... [0x08048414]> ii : imports ... [0x08048414]> is : symtab entries ... [0x08048414]> izzz : dump all strings from the binary ... 000 0x00000028 0x08048028 4 10 (LOAD0) utf16le 4 \\t( 001 0x00000154 0x08048154 18 19 (.interp) ascii /lib/ld-linux.so.2 [0x08048414]> izzz~Password 014 0x00000581 0x08048581 10 11 (.rodata) ascii Password: 016 0x00000596 0x08048596 18 19 (.rodata) ascii Invalid Password!\\n 017 0x000005a9 0x080485a9 15 16 (.rodata) ascii Password OK :)\\n","title":"Investigating binary"},{"location":"radare2-workthrough/#investigate-function","text":"[0x08048493]> s main # seek to main symbol [0x08048414]> pdf # disasemble function ... [0x08048414]> pdc ; decompiled code [0x08048414]> v # visual mode - rotate with 'p', hex, disasm, debug, words, buf; exit with 'q' [0x08048414]> VV # visual mode graph; rotate with 'p' for different BB representations; exit with 'q' [0x0804848c]> ps @ str.250382 # string type variable 250382 [0x0804848c]> s str.250382 [0x0804858f]> pds ;-- str.250382: 0x0804858f \"250382\" ;-- str.Invalid_Password: 0x08048596 \"Invalid Password!\\n\" ...","title":"Investigate function"},{"location":"radare2-workthrough/#basic-command-format","text":"Command syntax: [.][times][cmd][~grep][@[@iter]addr!size][|>pipe] * ; Command chaining: x 3;s+3;pi 3;s+3;pxo 4; * | Pipe with shell commands: pd | less * ! Run shell commands: !cat /etc/passwd * !! Escapes to shell, run command and pass output to radare buffer * Note: The double exclamation mark tells radare to skip the plugin list to find an IO plugin handling this command to launch it directly to the shell. A single one will walk through the io plugin list. * ` Radare commands: wx `!ragg2 -i exec` * ~ grep * ~! grep -v * ~[n] grep by columns afl~[0] * ~:n grep by rows afl~:0 pi~mov,eax ; lines with mov or eax pi~mov&eax ; lines with mov and eax pi~mov,eax:6 ; 6 first lines with mov or eax pd 20~call[0]:0 ; grep first column of the first row matching 'call' .cmd Interprets command output is* prints symbols .is* interprets output and define the symbols in radare (normally they are already loaded if r2 was not invoked with -n) .. repeats last commands (same as enter \\n) ( Used to define and run macros $ Used to define alias $$ : Resolves to current address Offsets ( @ ) are absolute, we can use $$ for relative ones @ $$+4 ? Evaluate expression [0x00000000]> ? 33 +2 35 0x23 043 0000:0023 35 00100011 35.0 0.000000 Note: | and & need to be escaped ?$? Help for variables used in expressions $$ : Here $s : File size $b : Block size $l : Opcode length $j : When $$ is at a jmp , $j is the address where we are going to jump to $f : Same for jmp fail address $m : Opcode memory reference (e.g. mov eax,[0x10] => 0x10) ??? Help for ? command ?i Takes input from stdin. Eg ?i username ?? Result from previous operations ?s from to [step] : Generates sequence from to every ?p : Get physical address for given virtual address ?P : Get virtual address for given physical one ?v Show hex value of math expr ?v 0x1625d4ca ^ 0x72ca4247 = 0x64ef968d ?v 0x4141414a - 0x41414140 = 0xa ?l str : Returns the length of string @@ : Used for iterations wx ff @@10 20 30 Writes ff at offsets 10, 20 and 30 wx ff @@`?s 1 10 2` Writes ff at offsets 1, 2 and 3 wx 90 @@ sym.* Writes a nop on every symbol","title":"Basic Command format"},{"location":"schedule/","text":"Schedule Please note that the course schedule is now tenatitive . It is under subject of change upon the instructor\u2019s decision. .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} Topics Resources Papers Schedule & Assignments Week 1 (Aug 23, 2019) Course overview and logistics ; Basics of computer system operation TPM online tutorial , Rethinking PID 1 N/A N/A Week 2 (Aug 30, 2019) Binary and Process - Basic Concepts X86 assembly, The ELF file format Linux x86 Program Start Up, Program in Memory, Load-time reloc. of shared libraries How to read / present academic papers readelf , objdump , nm , GDB , gdbinit , Online x86 Assembler Microsoft Detour Week 3 (Sep 6, 2019) Memory Corruption Attacks & Defenses Buffer overflow, Stack buffer overflow x86 NX support, Stack canaries, ASLR System call tracing with library interpostion IDA pro, Ghidra, Radare2 Quiz: Reverse engineering binaries Week 4 (Sep 13, 2019) Modern Binary Exploits Shellcode, Return-Oriented Programming (ROP), ret2libc, Control Flow Integrity Control Flow Integrity Assignment 0x01: Binary Exploit 1-0-1 Week 5 (Sep 20, 2019) Virtualization Basics Return Oriented Programming Project proposal Due Week 6 (Sep 27, 2019) VMM Introspection 1 [TBD] Assignment 0x01 Due Week 7 (Sep 28, 2019) VMM Introspection 2 [TBD] Week 8 (Oct 4, 2019) Static Analysis 1 [TBD] Assignment 0x02 Week 9 (Oct 11, 2019) Static Analysis 2 [TBD] Week 10 (Oct 18, 2019) Static Analysis 3 [TBD] Assignment 0x02 Due Week 11 (Oct 25, 2019) Fuzzing and Symbolic Execution [TBD] Week 12 (Nov 1, 2019) Attacker techniques [TBD] Midterm Report Week 13 (Nov 8, 2019) Latest security topics 1 [TBD] Assignment 0x03 Week 14 (Nov 15, 2019) Latest security topics 2 [TBD] Week 15 (Nov 22, 2019) Latest security topics 3 [TBD] Assignment 0x03 due Week 16 (Nov 29, 2019) No class (Thanksgiving break) Week 17 (Dec 6, 2019) Project Presentation Project Final Report & Presentation Page last revised on: 2019-09-13","title":"Schedule"},{"location":"schedule/#schedule","text":"Please note that the course schedule is now tenatitive . It is under subject of change upon the instructor\u2019s decision. .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} Topics Resources Papers Schedule & Assignments Week 1 (Aug 23, 2019) Course overview and logistics ; Basics of computer system operation TPM online tutorial , Rethinking PID 1 N/A N/A Week 2 (Aug 30, 2019) Binary and Process - Basic Concepts X86 assembly, The ELF file format Linux x86 Program Start Up, Program in Memory, Load-time reloc. of shared libraries How to read / present academic papers readelf , objdump , nm , GDB , gdbinit , Online x86 Assembler Microsoft Detour Week 3 (Sep 6, 2019) Memory Corruption Attacks & Defenses Buffer overflow, Stack buffer overflow x86 NX support, Stack canaries, ASLR System call tracing with library interpostion IDA pro, Ghidra, Radare2 Quiz: Reverse engineering binaries Week 4 (Sep 13, 2019) Modern Binary Exploits Shellcode, Return-Oriented Programming (ROP), ret2libc, Control Flow Integrity Control Flow Integrity Assignment 0x01: Binary Exploit 1-0-1 Week 5 (Sep 20, 2019) Virtualization Basics Return Oriented Programming Project proposal Due Week 6 (Sep 27, 2019) VMM Introspection 1 [TBD] Assignment 0x01 Due Week 7 (Sep 28, 2019) VMM Introspection 2 [TBD] Week 8 (Oct 4, 2019) Static Analysis 1 [TBD] Assignment 0x02 Week 9 (Oct 11, 2019) Static Analysis 2 [TBD] Week 10 (Oct 18, 2019) Static Analysis 3 [TBD] Assignment 0x02 Due Week 11 (Oct 25, 2019) Fuzzing and Symbolic Execution [TBD] Week 12 (Nov 1, 2019) Attacker techniques [TBD] Midterm Report Week 13 (Nov 8, 2019) Latest security topics 1 [TBD] Assignment 0x03 Week 14 (Nov 15, 2019) Latest security topics 2 [TBD] Week 15 (Nov 22, 2019) Latest security topics 3 [TBD] Assignment 0x03 due Week 16 (Nov 29, 2019) No class (Thanksgiving break) Week 17 (Dec 6, 2019) Project Presentation Project Final Report & Presentation Page last revised on: 2019-09-13","title":"Schedule"}]}